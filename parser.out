Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> exp
Rule 1     exp -> ID + ASG exp
Rule 2     exp -> ID - ASG exp
Rule 3     exp -> ID * ASG exp
Rule 4     exp -> ID DIV ASG exp
Rule 5     exp -> ID POW ASG exp
Rule 6     exp -> ID or ASG exp
Rule 7     exp -> ID xor ASG exp
Rule 8     exp -> ID and ASG exp
Rule 9     exp -> ID ASG exp
Rule 10    exp -> ID USG
Rule 11    exp -> exp + exp
Rule 12    exp -> exp - exp
Rule 13    exp -> exp * exp
Rule 14    exp -> exp DIV exp
Rule 15    exp -> exp POW exp
Rule 16    exp -> exp or exp
Rule 17    exp -> exp xor exp
Rule 18    exp -> exp and exp
Rule 19    cmp -> exp CMP exp
Rule 20    cmp -> cmp CMP exp
Rule 21    exp -> cmp
Rule 22    ifc -> IF exp THEN exp
Rule 23    ifc -> IF exp THEN exp ELSE exp
Rule 24    ifc -> IF exp THEN exp ELSE ifc
Rule 25    exp -> ifc END
Rule 26    exp -> FOR ID IN it DO exp END
Rule 27    exp -> ( exp )
Rule 28    exp -> ID
Rule 29    it -> [ exp , exp ]
Rule 30    it -> ] exp , exp ]
Rule 31    it -> [ exp , exp [
Rule 32    it -> ] exp , exp [
Rule 33    exp -> it
Rule 34    exp -> exp IN it
Rule 35    exp -> ID + exp
Rule 36    exp -> ID - exp
Rule 37    exp -> ID * exp
Rule 38    exp -> ID DIV exp
Rule 39    exp -> ID POW exp
Rule 40    exp -> ID or exp
Rule 41    exp -> ID xor exp
Rule 42    exp -> ID and exp
Rule 43    exp -> + exp
Rule 44    exp -> - exp
Rule 45    exp -> not exp
Rule 46    exp -> SYS exp
Rule 47    seq -> exp ; seq
Rule 48    seq -> exp ;
Rule 49    seq -> exp
Rule 50    exp -> { seq }
Rule 51    exp -> STR
Rule 52    exp -> exp imag
Rule 53    exp -> NUM
Rule 54    exp -> WHILE exp DO exp END

Terminals, with rules where they appear

(                    : 27
)                    : 27
*                    : 3 13 37
+                    : 1 11 35 43
,                    : 29 30 31 32
-                    : 2 12 36 44
;                    : 47 48
ASG                  : 1 2 3 4 5 6 7 8 9
CMP                  : 19 20
DIV                  : 4 14 38
DO                   : 26 54
ELSE                 : 23 24
END                  : 25 26 54
FOR                  : 26
ID                   : 1 2 3 4 5 6 7 8 9 10 26 28 35 36 37 38 39 40 41 42
IF                   : 22 23 24
IN                   : 26 34
NUM                  : 53
POW                  : 5 15 39
STR                  : 51
SYS                  : 46
THEN                 : 22 23 24
USG                  : 10
WHILE                : 54
[                    : 29 31 31 32
]                    : 29 30 30 32
and                  : 8 18 42
error                : 
imag                 : 52
not                  : 45
or                   : 6 16 40
xor                  : 7 17 41
{                    : 50
}                    : 50

Nonterminals, with rules where they appear

cmp                  : 20 21
exp                  : 1 2 3 4 5 6 7 8 9 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 22 22 23 23 23 24 24 26 27 29 29 30 30 31 31 32 32 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 52 54 54 0
ifc                  : 24 25
it                   : 26 33 34
seq                  : 47 50

Parsing method: LALR

state 0

    (0) S' -> . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 1
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 1

    (0) S' -> exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 2

    (1) exp -> ID . + ASG exp
    (2) exp -> ID . - ASG exp
    (3) exp -> ID . * ASG exp
    (4) exp -> ID . DIV ASG exp
    (5) exp -> ID . POW ASG exp
    (6) exp -> ID . or ASG exp
    (7) exp -> ID . xor ASG exp
    (8) exp -> ID . and ASG exp
    (9) exp -> ID . ASG exp
    (10) exp -> ID . USG
    (28) exp -> ID .
    (35) exp -> ID . + exp
    (36) exp -> ID . - exp
    (37) exp -> ID . * exp
    (38) exp -> ID . DIV exp
    (39) exp -> ID . POW exp
    (40) exp -> ID . or exp
    (41) exp -> ID . xor exp
    (42) exp -> ID . and exp

    +               shift and go to state 30
    -               shift and go to state 32
    *               shift and go to state 33
    DIV             shift and go to state 34
    POW             shift and go to state 35
    or              shift and go to state 36
    xor             shift and go to state 37
    and             shift and go to state 38
    ASG             shift and go to state 31
    USG             shift and go to state 39
    IN              reduce using rule 28 (exp -> ID .)
    imag            reduce using rule 28 (exp -> ID .)
    CMP             reduce using rule 28 (exp -> ID .)
    $end            reduce using rule 28 (exp -> ID .)
    )               reduce using rule 28 (exp -> ID .)
    ;               reduce using rule 28 (exp -> ID .)
    }               reduce using rule 28 (exp -> ID .)
    DO              reduce using rule 28 (exp -> ID .)
    THEN            reduce using rule 28 (exp -> ID .)
    ,               reduce using rule 28 (exp -> ID .)
    END             reduce using rule 28 (exp -> ID .)
    ELSE            reduce using rule 28 (exp -> ID .)
    ]               reduce using rule 28 (exp -> ID .)
    [               reduce using rule 28 (exp -> ID .)

  ! +               [ reduce using rule 28 (exp -> ID .) ]
  ! -               [ reduce using rule 28 (exp -> ID .) ]
  ! *               [ reduce using rule 28 (exp -> ID .) ]
  ! DIV             [ reduce using rule 28 (exp -> ID .) ]
  ! POW             [ reduce using rule 28 (exp -> ID .) ]
  ! or              [ reduce using rule 28 (exp -> ID .) ]
  ! xor             [ reduce using rule 28 (exp -> ID .) ]
  ! and             [ reduce using rule 28 (exp -> ID .) ]


state 3

    (43) exp -> + . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 40
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 4

    (44) exp -> - . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 41
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 5

    (21) exp -> cmp .
    (20) cmp -> cmp . CMP exp

    +               reduce using rule 21 (exp -> cmp .)
    -               reduce using rule 21 (exp -> cmp .)
    *               reduce using rule 21 (exp -> cmp .)
    DIV             reduce using rule 21 (exp -> cmp .)
    POW             reduce using rule 21 (exp -> cmp .)
    or              reduce using rule 21 (exp -> cmp .)
    xor             reduce using rule 21 (exp -> cmp .)
    and             reduce using rule 21 (exp -> cmp .)
    IN              reduce using rule 21 (exp -> cmp .)
    imag            reduce using rule 21 (exp -> cmp .)
    $end            reduce using rule 21 (exp -> cmp .)
    )               reduce using rule 21 (exp -> cmp .)
    ;               reduce using rule 21 (exp -> cmp .)
    }               reduce using rule 21 (exp -> cmp .)
    DO              reduce using rule 21 (exp -> cmp .)
    THEN            reduce using rule 21 (exp -> cmp .)
    ,               reduce using rule 21 (exp -> cmp .)
    END             reduce using rule 21 (exp -> cmp .)
    ELSE            reduce using rule 21 (exp -> cmp .)
    ]               reduce using rule 21 (exp -> cmp .)
    [               reduce using rule 21 (exp -> cmp .)
    CMP             shift and go to state 42

  ! CMP             [ reduce using rule 21 (exp -> cmp .) ]


state 6

    (25) exp -> ifc . END

    END             shift and go to state 43


state 7

    (26) exp -> FOR . ID IN it DO exp END

    ID              shift and go to state 44


state 8

    (33) exp -> it .

    +               reduce using rule 33 (exp -> it .)
    -               reduce using rule 33 (exp -> it .)
    *               reduce using rule 33 (exp -> it .)
    DIV             reduce using rule 33 (exp -> it .)
    POW             reduce using rule 33 (exp -> it .)
    or              reduce using rule 33 (exp -> it .)
    xor             reduce using rule 33 (exp -> it .)
    and             reduce using rule 33 (exp -> it .)
    IN              reduce using rule 33 (exp -> it .)
    imag            reduce using rule 33 (exp -> it .)
    CMP             reduce using rule 33 (exp -> it .)
    $end            reduce using rule 33 (exp -> it .)
    )               reduce using rule 33 (exp -> it .)
    ;               reduce using rule 33 (exp -> it .)
    }               reduce using rule 33 (exp -> it .)
    DO              reduce using rule 33 (exp -> it .)
    THEN            reduce using rule 33 (exp -> it .)
    ,               reduce using rule 33 (exp -> it .)
    END             reduce using rule 33 (exp -> it .)
    ELSE            reduce using rule 33 (exp -> it .)
    ]               reduce using rule 33 (exp -> it .)
    [               reduce using rule 33 (exp -> it .)


state 9

    (27) exp -> ( . exp )
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 45
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 10

    (45) exp -> not . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 46
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 11

    (46) exp -> SYS . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 47
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 12

    (50) exp -> { . seq }
    (47) seq -> . exp ; seq
    (48) seq -> . exp ;
    (49) seq -> . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    seq                            shift and go to state 48
    exp                            shift and go to state 49
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 13

    (51) exp -> STR .

    +               reduce using rule 51 (exp -> STR .)
    -               reduce using rule 51 (exp -> STR .)
    *               reduce using rule 51 (exp -> STR .)
    DIV             reduce using rule 51 (exp -> STR .)
    POW             reduce using rule 51 (exp -> STR .)
    or              reduce using rule 51 (exp -> STR .)
    xor             reduce using rule 51 (exp -> STR .)
    and             reduce using rule 51 (exp -> STR .)
    IN              reduce using rule 51 (exp -> STR .)
    imag            reduce using rule 51 (exp -> STR .)
    CMP             reduce using rule 51 (exp -> STR .)
    $end            reduce using rule 51 (exp -> STR .)
    )               reduce using rule 51 (exp -> STR .)
    ;               reduce using rule 51 (exp -> STR .)
    }               reduce using rule 51 (exp -> STR .)
    DO              reduce using rule 51 (exp -> STR .)
    THEN            reduce using rule 51 (exp -> STR .)
    ,               reduce using rule 51 (exp -> STR .)
    END             reduce using rule 51 (exp -> STR .)
    ELSE            reduce using rule 51 (exp -> STR .)
    ]               reduce using rule 51 (exp -> STR .)
    [               reduce using rule 51 (exp -> STR .)


state 14

    (53) exp -> NUM .

    +               reduce using rule 53 (exp -> NUM .)
    -               reduce using rule 53 (exp -> NUM .)
    *               reduce using rule 53 (exp -> NUM .)
    DIV             reduce using rule 53 (exp -> NUM .)
    POW             reduce using rule 53 (exp -> NUM .)
    or              reduce using rule 53 (exp -> NUM .)
    xor             reduce using rule 53 (exp -> NUM .)
    and             reduce using rule 53 (exp -> NUM .)
    IN              reduce using rule 53 (exp -> NUM .)
    imag            reduce using rule 53 (exp -> NUM .)
    CMP             reduce using rule 53 (exp -> NUM .)
    $end            reduce using rule 53 (exp -> NUM .)
    )               reduce using rule 53 (exp -> NUM .)
    ;               reduce using rule 53 (exp -> NUM .)
    }               reduce using rule 53 (exp -> NUM .)
    DO              reduce using rule 53 (exp -> NUM .)
    THEN            reduce using rule 53 (exp -> NUM .)
    ,               reduce using rule 53 (exp -> NUM .)
    END             reduce using rule 53 (exp -> NUM .)
    ELSE            reduce using rule 53 (exp -> NUM .)
    ]               reduce using rule 53 (exp -> NUM .)
    [               reduce using rule 53 (exp -> NUM .)


state 15

    (54) exp -> WHILE . exp DO exp END
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 50
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 16

    (22) ifc -> IF . exp THEN exp
    (23) ifc -> IF . exp THEN exp ELSE exp
    (24) ifc -> IF . exp THEN exp ELSE ifc
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 51
    ifc                            shift and go to state 6
    cmp                            shift and go to state 5
    it                             shift and go to state 8

state 17

    (29) it -> [ . exp , exp ]
    (31) it -> [ . exp , exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 52
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 18

    (30) it -> ] . exp , exp ]
    (32) it -> ] . exp , exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 53
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 19

    (11) exp -> exp + . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 54
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 20

    (12) exp -> exp - . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 55
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 21

    (13) exp -> exp * . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 56
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 22

    (14) exp -> exp DIV . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 57
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 23

    (15) exp -> exp POW . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 58
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 24

    (16) exp -> exp or . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 59
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 25

    (17) exp -> exp xor . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 60
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 26

    (18) exp -> exp and . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 61
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 27

    (34) exp -> exp IN . it
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    [               shift and go to state 17
    ]               shift and go to state 18

    it                             shift and go to state 62

state 28

    (52) exp -> exp imag .

    +               reduce using rule 52 (exp -> exp imag .)
    -               reduce using rule 52 (exp -> exp imag .)
    *               reduce using rule 52 (exp -> exp imag .)
    DIV             reduce using rule 52 (exp -> exp imag .)
    POW             reduce using rule 52 (exp -> exp imag .)
    or              reduce using rule 52 (exp -> exp imag .)
    xor             reduce using rule 52 (exp -> exp imag .)
    and             reduce using rule 52 (exp -> exp imag .)
    IN              reduce using rule 52 (exp -> exp imag .)
    imag            reduce using rule 52 (exp -> exp imag .)
    CMP             reduce using rule 52 (exp -> exp imag .)
    $end            reduce using rule 52 (exp -> exp imag .)
    )               reduce using rule 52 (exp -> exp imag .)
    ;               reduce using rule 52 (exp -> exp imag .)
    }               reduce using rule 52 (exp -> exp imag .)
    DO              reduce using rule 52 (exp -> exp imag .)
    THEN            reduce using rule 52 (exp -> exp imag .)
    ,               reduce using rule 52 (exp -> exp imag .)
    END             reduce using rule 52 (exp -> exp imag .)
    ELSE            reduce using rule 52 (exp -> exp imag .)
    ]               reduce using rule 52 (exp -> exp imag .)
    [               reduce using rule 52 (exp -> exp imag .)


state 29

    (19) cmp -> exp CMP . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 63
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 30

    (1) exp -> ID + . ASG exp
    (35) exp -> ID + . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 64
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 65
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 31

    (9) exp -> ID ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 66
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 32

    (2) exp -> ID - . ASG exp
    (36) exp -> ID - . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 67
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 68
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 33

    (3) exp -> ID * . ASG exp
    (37) exp -> ID * . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 69
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 70
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 34

    (4) exp -> ID DIV . ASG exp
    (38) exp -> ID DIV . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 71
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 72
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 35

    (5) exp -> ID POW . ASG exp
    (39) exp -> ID POW . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 73
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 74
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 36

    (6) exp -> ID or . ASG exp
    (40) exp -> ID or . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 75
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 76
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 37

    (7) exp -> ID xor . ASG exp
    (41) exp -> ID xor . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 77
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 78
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 38

    (8) exp -> ID and . ASG exp
    (42) exp -> ID and . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 79
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 80
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 39

    (10) exp -> ID USG .

    +               reduce using rule 10 (exp -> ID USG .)
    -               reduce using rule 10 (exp -> ID USG .)
    *               reduce using rule 10 (exp -> ID USG .)
    DIV             reduce using rule 10 (exp -> ID USG .)
    POW             reduce using rule 10 (exp -> ID USG .)
    or              reduce using rule 10 (exp -> ID USG .)
    xor             reduce using rule 10 (exp -> ID USG .)
    and             reduce using rule 10 (exp -> ID USG .)
    IN              reduce using rule 10 (exp -> ID USG .)
    imag            reduce using rule 10 (exp -> ID USG .)
    CMP             reduce using rule 10 (exp -> ID USG .)
    $end            reduce using rule 10 (exp -> ID USG .)
    )               reduce using rule 10 (exp -> ID USG .)
    ;               reduce using rule 10 (exp -> ID USG .)
    }               reduce using rule 10 (exp -> ID USG .)
    DO              reduce using rule 10 (exp -> ID USG .)
    THEN            reduce using rule 10 (exp -> ID USG .)
    ,               reduce using rule 10 (exp -> ID USG .)
    END             reduce using rule 10 (exp -> ID USG .)
    ELSE            reduce using rule 10 (exp -> ID USG .)
    ]               reduce using rule 10 (exp -> ID USG .)
    [               reduce using rule 10 (exp -> ID USG .)


state 40

    (43) exp -> + exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 43 (exp -> + exp .)
    -               reduce using rule 43 (exp -> + exp .)
    or              reduce using rule 43 (exp -> + exp .)
    xor             reduce using rule 43 (exp -> + exp .)
    and             reduce using rule 43 (exp -> + exp .)
    IN              reduce using rule 43 (exp -> + exp .)
    CMP             reduce using rule 43 (exp -> + exp .)
    $end            reduce using rule 43 (exp -> + exp .)
    )               reduce using rule 43 (exp -> + exp .)
    ;               reduce using rule 43 (exp -> + exp .)
    }               reduce using rule 43 (exp -> + exp .)
    DO              reduce using rule 43 (exp -> + exp .)
    THEN            reduce using rule 43 (exp -> + exp .)
    ,               reduce using rule 43 (exp -> + exp .)
    END             reduce using rule 43 (exp -> + exp .)
    ELSE            reduce using rule 43 (exp -> + exp .)
    ]               reduce using rule 43 (exp -> + exp .)
    [               reduce using rule 43 (exp -> + exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! *               [ reduce using rule 43 (exp -> + exp .) ]
  ! DIV             [ reduce using rule 43 (exp -> + exp .) ]
  ! POW             [ reduce using rule 43 (exp -> + exp .) ]
  ! imag            [ reduce using rule 43 (exp -> + exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 41

    (44) exp -> - exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 44 (exp -> - exp .)
    -               reduce using rule 44 (exp -> - exp .)
    or              reduce using rule 44 (exp -> - exp .)
    xor             reduce using rule 44 (exp -> - exp .)
    and             reduce using rule 44 (exp -> - exp .)
    IN              reduce using rule 44 (exp -> - exp .)
    CMP             reduce using rule 44 (exp -> - exp .)
    $end            reduce using rule 44 (exp -> - exp .)
    )               reduce using rule 44 (exp -> - exp .)
    ;               reduce using rule 44 (exp -> - exp .)
    }               reduce using rule 44 (exp -> - exp .)
    DO              reduce using rule 44 (exp -> - exp .)
    THEN            reduce using rule 44 (exp -> - exp .)
    ,               reduce using rule 44 (exp -> - exp .)
    END             reduce using rule 44 (exp -> - exp .)
    ELSE            reduce using rule 44 (exp -> - exp .)
    ]               reduce using rule 44 (exp -> - exp .)
    [               reduce using rule 44 (exp -> - exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! *               [ reduce using rule 44 (exp -> - exp .) ]
  ! DIV             [ reduce using rule 44 (exp -> - exp .) ]
  ! POW             [ reduce using rule 44 (exp -> - exp .) ]
  ! imag            [ reduce using rule 44 (exp -> - exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 42

    (20) cmp -> cmp CMP . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    cmp                            shift and go to state 5
    exp                            shift and go to state 81
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 43

    (25) exp -> ifc END .

    +               reduce using rule 25 (exp -> ifc END .)
    -               reduce using rule 25 (exp -> ifc END .)
    *               reduce using rule 25 (exp -> ifc END .)
    DIV             reduce using rule 25 (exp -> ifc END .)
    POW             reduce using rule 25 (exp -> ifc END .)
    or              reduce using rule 25 (exp -> ifc END .)
    xor             reduce using rule 25 (exp -> ifc END .)
    and             reduce using rule 25 (exp -> ifc END .)
    IN              reduce using rule 25 (exp -> ifc END .)
    imag            reduce using rule 25 (exp -> ifc END .)
    CMP             reduce using rule 25 (exp -> ifc END .)
    $end            reduce using rule 25 (exp -> ifc END .)
    )               reduce using rule 25 (exp -> ifc END .)
    ;               reduce using rule 25 (exp -> ifc END .)
    }               reduce using rule 25 (exp -> ifc END .)
    DO              reduce using rule 25 (exp -> ifc END .)
    THEN            reduce using rule 25 (exp -> ifc END .)
    ,               reduce using rule 25 (exp -> ifc END .)
    END             reduce using rule 25 (exp -> ifc END .)
    ELSE            reduce using rule 25 (exp -> ifc END .)
    ]               reduce using rule 25 (exp -> ifc END .)
    [               reduce using rule 25 (exp -> ifc END .)


state 44

    (26) exp -> FOR ID . IN it DO exp END

    IN              shift and go to state 82


state 45

    (27) exp -> ( exp . )
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    )               shift and go to state 83
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 46

    (45) exp -> not exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 45 (exp -> not exp .)
    -               reduce using rule 45 (exp -> not exp .)
    *               reduce using rule 45 (exp -> not exp .)
    DIV             reduce using rule 45 (exp -> not exp .)
    POW             reduce using rule 45 (exp -> not exp .)
    or              reduce using rule 45 (exp -> not exp .)
    xor             reduce using rule 45 (exp -> not exp .)
    and             reduce using rule 45 (exp -> not exp .)
    IN              reduce using rule 45 (exp -> not exp .)
    imag            reduce using rule 45 (exp -> not exp .)
    CMP             reduce using rule 45 (exp -> not exp .)
    $end            reduce using rule 45 (exp -> not exp .)
    )               reduce using rule 45 (exp -> not exp .)
    ;               reduce using rule 45 (exp -> not exp .)
    }               reduce using rule 45 (exp -> not exp .)
    DO              reduce using rule 45 (exp -> not exp .)
    THEN            reduce using rule 45 (exp -> not exp .)
    ,               reduce using rule 45 (exp -> not exp .)
    END             reduce using rule 45 (exp -> not exp .)
    ELSE            reduce using rule 45 (exp -> not exp .)
    ]               reduce using rule 45 (exp -> not exp .)
    [               reduce using rule 45 (exp -> not exp .)

  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! POW             [ shift and go to state 23 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! imag            [ shift and go to state 28 ]
  ! CMP             [ shift and go to state 29 ]


state 47

    (46) exp -> SYS exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 46 (exp -> SYS exp .)
    $end            reduce using rule 46 (exp -> SYS exp .)
    )               reduce using rule 46 (exp -> SYS exp .)
    ;               reduce using rule 46 (exp -> SYS exp .)
    }               reduce using rule 46 (exp -> SYS exp .)
    DO              reduce using rule 46 (exp -> SYS exp .)
    THEN            reduce using rule 46 (exp -> SYS exp .)
    ,               reduce using rule 46 (exp -> SYS exp .)
    END             reduce using rule 46 (exp -> SYS exp .)
    ELSE            reduce using rule 46 (exp -> SYS exp .)
    ]               reduce using rule 46 (exp -> SYS exp .)
    [               reduce using rule 46 (exp -> SYS exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 46 (exp -> SYS exp .) ]
  ! -               [ reduce using rule 46 (exp -> SYS exp .) ]
  ! *               [ reduce using rule 46 (exp -> SYS exp .) ]
  ! DIV             [ reduce using rule 46 (exp -> SYS exp .) ]
  ! POW             [ reduce using rule 46 (exp -> SYS exp .) ]
  ! or              [ reduce using rule 46 (exp -> SYS exp .) ]
  ! xor             [ reduce using rule 46 (exp -> SYS exp .) ]
  ! and             [ reduce using rule 46 (exp -> SYS exp .) ]
  ! imag            [ reduce using rule 46 (exp -> SYS exp .) ]
  ! CMP             [ reduce using rule 46 (exp -> SYS exp .) ]
  ! IN              [ shift and go to state 27 ]


state 48

    (50) exp -> { seq . }

    }               shift and go to state 84


state 49

    (47) seq -> exp . ; seq
    (48) seq -> exp . ;
    (49) seq -> exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ;               shift and go to state 85
    }               reduce using rule 49 (seq -> exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 50

    (54) exp -> WHILE exp . DO exp END
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    DO              shift and go to state 86
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 51

    (22) ifc -> IF exp . THEN exp
    (23) ifc -> IF exp . THEN exp ELSE exp
    (24) ifc -> IF exp . THEN exp ELSE ifc
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    THEN            shift and go to state 87
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 52

    (29) it -> [ exp . , exp ]
    (31) it -> [ exp . , exp [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ,               shift and go to state 88
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 53

    (30) it -> ] exp . , exp ]
    (32) it -> ] exp . , exp [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ,               shift and go to state 89
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 54

    (11) exp -> exp + exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 11 (exp -> exp + exp .)
    -               reduce using rule 11 (exp -> exp + exp .)
    or              reduce using rule 11 (exp -> exp + exp .)
    xor             reduce using rule 11 (exp -> exp + exp .)
    and             reduce using rule 11 (exp -> exp + exp .)
    IN              reduce using rule 11 (exp -> exp + exp .)
    CMP             reduce using rule 11 (exp -> exp + exp .)
    $end            reduce using rule 11 (exp -> exp + exp .)
    )               reduce using rule 11 (exp -> exp + exp .)
    ;               reduce using rule 11 (exp -> exp + exp .)
    }               reduce using rule 11 (exp -> exp + exp .)
    DO              reduce using rule 11 (exp -> exp + exp .)
    THEN            reduce using rule 11 (exp -> exp + exp .)
    ,               reduce using rule 11 (exp -> exp + exp .)
    END             reduce using rule 11 (exp -> exp + exp .)
    ELSE            reduce using rule 11 (exp -> exp + exp .)
    ]               reduce using rule 11 (exp -> exp + exp .)
    [               reduce using rule 11 (exp -> exp + exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! *               [ reduce using rule 11 (exp -> exp + exp .) ]
  ! DIV             [ reduce using rule 11 (exp -> exp + exp .) ]
  ! POW             [ reduce using rule 11 (exp -> exp + exp .) ]
  ! imag            [ reduce using rule 11 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 55

    (12) exp -> exp - exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 12 (exp -> exp - exp .)
    -               reduce using rule 12 (exp -> exp - exp .)
    or              reduce using rule 12 (exp -> exp - exp .)
    xor             reduce using rule 12 (exp -> exp - exp .)
    and             reduce using rule 12 (exp -> exp - exp .)
    IN              reduce using rule 12 (exp -> exp - exp .)
    CMP             reduce using rule 12 (exp -> exp - exp .)
    $end            reduce using rule 12 (exp -> exp - exp .)
    )               reduce using rule 12 (exp -> exp - exp .)
    ;               reduce using rule 12 (exp -> exp - exp .)
    }               reduce using rule 12 (exp -> exp - exp .)
    DO              reduce using rule 12 (exp -> exp - exp .)
    THEN            reduce using rule 12 (exp -> exp - exp .)
    ,               reduce using rule 12 (exp -> exp - exp .)
    END             reduce using rule 12 (exp -> exp - exp .)
    ELSE            reduce using rule 12 (exp -> exp - exp .)
    ]               reduce using rule 12 (exp -> exp - exp .)
    [               reduce using rule 12 (exp -> exp - exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! *               [ reduce using rule 12 (exp -> exp - exp .) ]
  ! DIV             [ reduce using rule 12 (exp -> exp - exp .) ]
  ! POW             [ reduce using rule 12 (exp -> exp - exp .) ]
  ! imag            [ reduce using rule 12 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 56

    (13) exp -> exp * exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 13 (exp -> exp * exp .)
    -               reduce using rule 13 (exp -> exp * exp .)
    *               reduce using rule 13 (exp -> exp * exp .)
    DIV             reduce using rule 13 (exp -> exp * exp .)
    or              reduce using rule 13 (exp -> exp * exp .)
    xor             reduce using rule 13 (exp -> exp * exp .)
    and             reduce using rule 13 (exp -> exp * exp .)
    IN              reduce using rule 13 (exp -> exp * exp .)
    CMP             reduce using rule 13 (exp -> exp * exp .)
    $end            reduce using rule 13 (exp -> exp * exp .)
    )               reduce using rule 13 (exp -> exp * exp .)
    ;               reduce using rule 13 (exp -> exp * exp .)
    }               reduce using rule 13 (exp -> exp * exp .)
    DO              reduce using rule 13 (exp -> exp * exp .)
    THEN            reduce using rule 13 (exp -> exp * exp .)
    ,               reduce using rule 13 (exp -> exp * exp .)
    END             reduce using rule 13 (exp -> exp * exp .)
    ELSE            reduce using rule 13 (exp -> exp * exp .)
    ]               reduce using rule 13 (exp -> exp * exp .)
    [               reduce using rule 13 (exp -> exp * exp .)
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! POW             [ reduce using rule 13 (exp -> exp * exp .) ]
  ! imag            [ reduce using rule 13 (exp -> exp * exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 57

    (14) exp -> exp DIV exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 14 (exp -> exp DIV exp .)
    -               reduce using rule 14 (exp -> exp DIV exp .)
    *               reduce using rule 14 (exp -> exp DIV exp .)
    DIV             reduce using rule 14 (exp -> exp DIV exp .)
    or              reduce using rule 14 (exp -> exp DIV exp .)
    xor             reduce using rule 14 (exp -> exp DIV exp .)
    and             reduce using rule 14 (exp -> exp DIV exp .)
    IN              reduce using rule 14 (exp -> exp DIV exp .)
    CMP             reduce using rule 14 (exp -> exp DIV exp .)
    $end            reduce using rule 14 (exp -> exp DIV exp .)
    )               reduce using rule 14 (exp -> exp DIV exp .)
    ;               reduce using rule 14 (exp -> exp DIV exp .)
    }               reduce using rule 14 (exp -> exp DIV exp .)
    DO              reduce using rule 14 (exp -> exp DIV exp .)
    THEN            reduce using rule 14 (exp -> exp DIV exp .)
    ,               reduce using rule 14 (exp -> exp DIV exp .)
    END             reduce using rule 14 (exp -> exp DIV exp .)
    ELSE            reduce using rule 14 (exp -> exp DIV exp .)
    ]               reduce using rule 14 (exp -> exp DIV exp .)
    [               reduce using rule 14 (exp -> exp DIV exp .)
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! POW             [ reduce using rule 14 (exp -> exp DIV exp .) ]
  ! imag            [ reduce using rule 14 (exp -> exp DIV exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 58

    (15) exp -> exp POW exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 15 (exp -> exp POW exp .)
    -               reduce using rule 15 (exp -> exp POW exp .)
    *               reduce using rule 15 (exp -> exp POW exp .)
    DIV             reduce using rule 15 (exp -> exp POW exp .)
    or              reduce using rule 15 (exp -> exp POW exp .)
    xor             reduce using rule 15 (exp -> exp POW exp .)
    and             reduce using rule 15 (exp -> exp POW exp .)
    IN              reduce using rule 15 (exp -> exp POW exp .)
    CMP             reduce using rule 15 (exp -> exp POW exp .)
    $end            reduce using rule 15 (exp -> exp POW exp .)
    )               reduce using rule 15 (exp -> exp POW exp .)
    ;               reduce using rule 15 (exp -> exp POW exp .)
    }               reduce using rule 15 (exp -> exp POW exp .)
    DO              reduce using rule 15 (exp -> exp POW exp .)
    THEN            reduce using rule 15 (exp -> exp POW exp .)
    ,               reduce using rule 15 (exp -> exp POW exp .)
    END             reduce using rule 15 (exp -> exp POW exp .)
    ELSE            reduce using rule 15 (exp -> exp POW exp .)
    ]               reduce using rule 15 (exp -> exp POW exp .)
    [               reduce using rule 15 (exp -> exp POW exp .)
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! POW             [ reduce using rule 15 (exp -> exp POW exp .) ]
  ! imag            [ reduce using rule 15 (exp -> exp POW exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 59

    (16) exp -> exp or exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 16 (exp -> exp or exp .)
    IN              reduce using rule 16 (exp -> exp or exp .)
    $end            reduce using rule 16 (exp -> exp or exp .)
    )               reduce using rule 16 (exp -> exp or exp .)
    ;               reduce using rule 16 (exp -> exp or exp .)
    }               reduce using rule 16 (exp -> exp or exp .)
    DO              reduce using rule 16 (exp -> exp or exp .)
    THEN            reduce using rule 16 (exp -> exp or exp .)
    ,               reduce using rule 16 (exp -> exp or exp .)
    END             reduce using rule 16 (exp -> exp or exp .)
    ELSE            reduce using rule 16 (exp -> exp or exp .)
    ]               reduce using rule 16 (exp -> exp or exp .)
    [               reduce using rule 16 (exp -> exp or exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 16 (exp -> exp or exp .) ]
  ! -               [ reduce using rule 16 (exp -> exp or exp .) ]
  ! *               [ reduce using rule 16 (exp -> exp or exp .) ]
  ! DIV             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! POW             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! xor             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! and             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! imag            [ reduce using rule 16 (exp -> exp or exp .) ]
  ! CMP             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! or              [ shift and go to state 24 ]
  ! IN              [ shift and go to state 27 ]


state 60

    (17) exp -> exp xor exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 17 (exp -> exp xor exp .)
    xor             reduce using rule 17 (exp -> exp xor exp .)
    IN              reduce using rule 17 (exp -> exp xor exp .)
    $end            reduce using rule 17 (exp -> exp xor exp .)
    )               reduce using rule 17 (exp -> exp xor exp .)
    ;               reduce using rule 17 (exp -> exp xor exp .)
    }               reduce using rule 17 (exp -> exp xor exp .)
    DO              reduce using rule 17 (exp -> exp xor exp .)
    THEN            reduce using rule 17 (exp -> exp xor exp .)
    ,               reduce using rule 17 (exp -> exp xor exp .)
    END             reduce using rule 17 (exp -> exp xor exp .)
    ELSE            reduce using rule 17 (exp -> exp xor exp .)
    ]               reduce using rule 17 (exp -> exp xor exp .)
    [               reduce using rule 17 (exp -> exp xor exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! -               [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! *               [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! DIV             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! POW             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! and             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! imag            [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! CMP             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! IN              [ shift and go to state 27 ]


state 61

    (18) exp -> exp and exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 18 (exp -> exp and exp .)
    xor             reduce using rule 18 (exp -> exp and exp .)
    and             reduce using rule 18 (exp -> exp and exp .)
    IN              reduce using rule 18 (exp -> exp and exp .)
    $end            reduce using rule 18 (exp -> exp and exp .)
    )               reduce using rule 18 (exp -> exp and exp .)
    ;               reduce using rule 18 (exp -> exp and exp .)
    }               reduce using rule 18 (exp -> exp and exp .)
    DO              reduce using rule 18 (exp -> exp and exp .)
    THEN            reduce using rule 18 (exp -> exp and exp .)
    ,               reduce using rule 18 (exp -> exp and exp .)
    END             reduce using rule 18 (exp -> exp and exp .)
    ELSE            reduce using rule 18 (exp -> exp and exp .)
    ]               reduce using rule 18 (exp -> exp and exp .)
    [               reduce using rule 18 (exp -> exp and exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 18 (exp -> exp and exp .) ]
  ! -               [ reduce using rule 18 (exp -> exp and exp .) ]
  ! *               [ reduce using rule 18 (exp -> exp and exp .) ]
  ! DIV             [ reduce using rule 18 (exp -> exp and exp .) ]
  ! POW             [ reduce using rule 18 (exp -> exp and exp .) ]
  ! imag            [ reduce using rule 18 (exp -> exp and exp .) ]
  ! CMP             [ reduce using rule 18 (exp -> exp and exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]


state 62

    (34) exp -> exp IN it .

    +               reduce using rule 34 (exp -> exp IN it .)
    -               reduce using rule 34 (exp -> exp IN it .)
    *               reduce using rule 34 (exp -> exp IN it .)
    DIV             reduce using rule 34 (exp -> exp IN it .)
    POW             reduce using rule 34 (exp -> exp IN it .)
    or              reduce using rule 34 (exp -> exp IN it .)
    xor             reduce using rule 34 (exp -> exp IN it .)
    and             reduce using rule 34 (exp -> exp IN it .)
    IN              reduce using rule 34 (exp -> exp IN it .)
    imag            reduce using rule 34 (exp -> exp IN it .)
    CMP             reduce using rule 34 (exp -> exp IN it .)
    $end            reduce using rule 34 (exp -> exp IN it .)
    )               reduce using rule 34 (exp -> exp IN it .)
    ;               reduce using rule 34 (exp -> exp IN it .)
    }               reduce using rule 34 (exp -> exp IN it .)
    DO              reduce using rule 34 (exp -> exp IN it .)
    THEN            reduce using rule 34 (exp -> exp IN it .)
    ,               reduce using rule 34 (exp -> exp IN it .)
    END             reduce using rule 34 (exp -> exp IN it .)
    ELSE            reduce using rule 34 (exp -> exp IN it .)
    ]               reduce using rule 34 (exp -> exp IN it .)
    [               reduce using rule 34 (exp -> exp IN it .)


state 63

    (19) cmp -> exp CMP exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    CMP             reduce using rule 19 (cmp -> exp CMP exp .)
    or              reduce using rule 19 (cmp -> exp CMP exp .)
    xor             reduce using rule 19 (cmp -> exp CMP exp .)
    and             reduce using rule 19 (cmp -> exp CMP exp .)
    IN              reduce using rule 19 (cmp -> exp CMP exp .)
    $end            reduce using rule 19 (cmp -> exp CMP exp .)
    )               reduce using rule 19 (cmp -> exp CMP exp .)
    ;               reduce using rule 19 (cmp -> exp CMP exp .)
    }               reduce using rule 19 (cmp -> exp CMP exp .)
    DO              reduce using rule 19 (cmp -> exp CMP exp .)
    THEN            reduce using rule 19 (cmp -> exp CMP exp .)
    ,               reduce using rule 19 (cmp -> exp CMP exp .)
    END             reduce using rule 19 (cmp -> exp CMP exp .)
    ELSE            reduce using rule 19 (cmp -> exp CMP exp .)
    ]               reduce using rule 19 (cmp -> exp CMP exp .)
    [               reduce using rule 19 (cmp -> exp CMP exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! +               [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! -               [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! *               [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! DIV             [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! POW             [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! imag            [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 64

    (1) exp -> ID + ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 90
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 65

    (35) exp -> ID + exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 35 (exp -> ID + exp .)
    -               reduce using rule 35 (exp -> ID + exp .)
    or              reduce using rule 35 (exp -> ID + exp .)
    xor             reduce using rule 35 (exp -> ID + exp .)
    and             reduce using rule 35 (exp -> ID + exp .)
    IN              reduce using rule 35 (exp -> ID + exp .)
    CMP             reduce using rule 35 (exp -> ID + exp .)
    $end            reduce using rule 35 (exp -> ID + exp .)
    )               reduce using rule 35 (exp -> ID + exp .)
    ;               reduce using rule 35 (exp -> ID + exp .)
    }               reduce using rule 35 (exp -> ID + exp .)
    DO              reduce using rule 35 (exp -> ID + exp .)
    THEN            reduce using rule 35 (exp -> ID + exp .)
    ,               reduce using rule 35 (exp -> ID + exp .)
    END             reduce using rule 35 (exp -> ID + exp .)
    ELSE            reduce using rule 35 (exp -> ID + exp .)
    ]               reduce using rule 35 (exp -> ID + exp .)
    [               reduce using rule 35 (exp -> ID + exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! *               [ reduce using rule 35 (exp -> ID + exp .) ]
  ! DIV             [ reduce using rule 35 (exp -> ID + exp .) ]
  ! POW             [ reduce using rule 35 (exp -> ID + exp .) ]
  ! imag            [ reduce using rule 35 (exp -> ID + exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 66

    (9) exp -> ID ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 9 (exp -> ID ASG exp .)
    $end            reduce using rule 9 (exp -> ID ASG exp .)
    )               reduce using rule 9 (exp -> ID ASG exp .)
    ;               reduce using rule 9 (exp -> ID ASG exp .)
    }               reduce using rule 9 (exp -> ID ASG exp .)
    DO              reduce using rule 9 (exp -> ID ASG exp .)
    THEN            reduce using rule 9 (exp -> ID ASG exp .)
    ,               reduce using rule 9 (exp -> ID ASG exp .)
    END             reduce using rule 9 (exp -> ID ASG exp .)
    ELSE            reduce using rule 9 (exp -> ID ASG exp .)
    ]               reduce using rule 9 (exp -> ID ASG exp .)
    [               reduce using rule 9 (exp -> ID ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! -               [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! *               [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! DIV             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! POW             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! or              [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! xor             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! and             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! imag            [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! CMP             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 67

    (2) exp -> ID - ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 91
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 68

    (36) exp -> ID - exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 36 (exp -> ID - exp .)
    -               reduce using rule 36 (exp -> ID - exp .)
    or              reduce using rule 36 (exp -> ID - exp .)
    xor             reduce using rule 36 (exp -> ID - exp .)
    and             reduce using rule 36 (exp -> ID - exp .)
    IN              reduce using rule 36 (exp -> ID - exp .)
    CMP             reduce using rule 36 (exp -> ID - exp .)
    $end            reduce using rule 36 (exp -> ID - exp .)
    )               reduce using rule 36 (exp -> ID - exp .)
    ;               reduce using rule 36 (exp -> ID - exp .)
    }               reduce using rule 36 (exp -> ID - exp .)
    DO              reduce using rule 36 (exp -> ID - exp .)
    THEN            reduce using rule 36 (exp -> ID - exp .)
    ,               reduce using rule 36 (exp -> ID - exp .)
    END             reduce using rule 36 (exp -> ID - exp .)
    ELSE            reduce using rule 36 (exp -> ID - exp .)
    ]               reduce using rule 36 (exp -> ID - exp .)
    [               reduce using rule 36 (exp -> ID - exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! *               [ reduce using rule 36 (exp -> ID - exp .) ]
  ! DIV             [ reduce using rule 36 (exp -> ID - exp .) ]
  ! POW             [ reduce using rule 36 (exp -> ID - exp .) ]
  ! imag            [ reduce using rule 36 (exp -> ID - exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 69

    (3) exp -> ID * ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 92
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 70

    (37) exp -> ID * exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 37 (exp -> ID * exp .)
    -               reduce using rule 37 (exp -> ID * exp .)
    *               reduce using rule 37 (exp -> ID * exp .)
    DIV             reduce using rule 37 (exp -> ID * exp .)
    or              reduce using rule 37 (exp -> ID * exp .)
    xor             reduce using rule 37 (exp -> ID * exp .)
    and             reduce using rule 37 (exp -> ID * exp .)
    IN              reduce using rule 37 (exp -> ID * exp .)
    CMP             reduce using rule 37 (exp -> ID * exp .)
    $end            reduce using rule 37 (exp -> ID * exp .)
    )               reduce using rule 37 (exp -> ID * exp .)
    ;               reduce using rule 37 (exp -> ID * exp .)
    }               reduce using rule 37 (exp -> ID * exp .)
    DO              reduce using rule 37 (exp -> ID * exp .)
    THEN            reduce using rule 37 (exp -> ID * exp .)
    ,               reduce using rule 37 (exp -> ID * exp .)
    END             reduce using rule 37 (exp -> ID * exp .)
    ELSE            reduce using rule 37 (exp -> ID * exp .)
    ]               reduce using rule 37 (exp -> ID * exp .)
    [               reduce using rule 37 (exp -> ID * exp .)
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! POW             [ reduce using rule 37 (exp -> ID * exp .) ]
  ! imag            [ reduce using rule 37 (exp -> ID * exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 71

    (4) exp -> ID DIV ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 93
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 72

    (38) exp -> ID DIV exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 38 (exp -> ID DIV exp .)
    -               reduce using rule 38 (exp -> ID DIV exp .)
    *               reduce using rule 38 (exp -> ID DIV exp .)
    DIV             reduce using rule 38 (exp -> ID DIV exp .)
    or              reduce using rule 38 (exp -> ID DIV exp .)
    xor             reduce using rule 38 (exp -> ID DIV exp .)
    and             reduce using rule 38 (exp -> ID DIV exp .)
    IN              reduce using rule 38 (exp -> ID DIV exp .)
    CMP             reduce using rule 38 (exp -> ID DIV exp .)
    $end            reduce using rule 38 (exp -> ID DIV exp .)
    )               reduce using rule 38 (exp -> ID DIV exp .)
    ;               reduce using rule 38 (exp -> ID DIV exp .)
    }               reduce using rule 38 (exp -> ID DIV exp .)
    DO              reduce using rule 38 (exp -> ID DIV exp .)
    THEN            reduce using rule 38 (exp -> ID DIV exp .)
    ,               reduce using rule 38 (exp -> ID DIV exp .)
    END             reduce using rule 38 (exp -> ID DIV exp .)
    ELSE            reduce using rule 38 (exp -> ID DIV exp .)
    ]               reduce using rule 38 (exp -> ID DIV exp .)
    [               reduce using rule 38 (exp -> ID DIV exp .)
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! POW             [ reduce using rule 38 (exp -> ID DIV exp .) ]
  ! imag            [ reduce using rule 38 (exp -> ID DIV exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 73

    (5) exp -> ID POW ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 94
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 74

    (39) exp -> ID POW exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 39 (exp -> ID POW exp .)
    -               reduce using rule 39 (exp -> ID POW exp .)
    *               reduce using rule 39 (exp -> ID POW exp .)
    DIV             reduce using rule 39 (exp -> ID POW exp .)
    or              reduce using rule 39 (exp -> ID POW exp .)
    xor             reduce using rule 39 (exp -> ID POW exp .)
    and             reduce using rule 39 (exp -> ID POW exp .)
    IN              reduce using rule 39 (exp -> ID POW exp .)
    CMP             reduce using rule 39 (exp -> ID POW exp .)
    $end            reduce using rule 39 (exp -> ID POW exp .)
    )               reduce using rule 39 (exp -> ID POW exp .)
    ;               reduce using rule 39 (exp -> ID POW exp .)
    }               reduce using rule 39 (exp -> ID POW exp .)
    DO              reduce using rule 39 (exp -> ID POW exp .)
    THEN            reduce using rule 39 (exp -> ID POW exp .)
    ,               reduce using rule 39 (exp -> ID POW exp .)
    END             reduce using rule 39 (exp -> ID POW exp .)
    ELSE            reduce using rule 39 (exp -> ID POW exp .)
    ]               reduce using rule 39 (exp -> ID POW exp .)
    [               reduce using rule 39 (exp -> ID POW exp .)
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! POW             [ reduce using rule 39 (exp -> ID POW exp .) ]
  ! imag            [ reduce using rule 39 (exp -> ID POW exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 75

    (6) exp -> ID or ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 95
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 76

    (40) exp -> ID or exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 40 (exp -> ID or exp .)
    IN              reduce using rule 40 (exp -> ID or exp .)
    $end            reduce using rule 40 (exp -> ID or exp .)
    )               reduce using rule 40 (exp -> ID or exp .)
    ;               reduce using rule 40 (exp -> ID or exp .)
    }               reduce using rule 40 (exp -> ID or exp .)
    DO              reduce using rule 40 (exp -> ID or exp .)
    THEN            reduce using rule 40 (exp -> ID or exp .)
    ,               reduce using rule 40 (exp -> ID or exp .)
    END             reduce using rule 40 (exp -> ID or exp .)
    ELSE            reduce using rule 40 (exp -> ID or exp .)
    ]               reduce using rule 40 (exp -> ID or exp .)
    [               reduce using rule 40 (exp -> ID or exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 40 (exp -> ID or exp .) ]
  ! -               [ reduce using rule 40 (exp -> ID or exp .) ]
  ! *               [ reduce using rule 40 (exp -> ID or exp .) ]
  ! DIV             [ reduce using rule 40 (exp -> ID or exp .) ]
  ! POW             [ reduce using rule 40 (exp -> ID or exp .) ]
  ! xor             [ reduce using rule 40 (exp -> ID or exp .) ]
  ! and             [ reduce using rule 40 (exp -> ID or exp .) ]
  ! imag            [ reduce using rule 40 (exp -> ID or exp .) ]
  ! CMP             [ reduce using rule 40 (exp -> ID or exp .) ]
  ! or              [ shift and go to state 24 ]
  ! IN              [ shift and go to state 27 ]


state 77

    (7) exp -> ID xor ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 96
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 78

    (41) exp -> ID xor exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 41 (exp -> ID xor exp .)
    xor             reduce using rule 41 (exp -> ID xor exp .)
    IN              reduce using rule 41 (exp -> ID xor exp .)
    $end            reduce using rule 41 (exp -> ID xor exp .)
    )               reduce using rule 41 (exp -> ID xor exp .)
    ;               reduce using rule 41 (exp -> ID xor exp .)
    }               reduce using rule 41 (exp -> ID xor exp .)
    DO              reduce using rule 41 (exp -> ID xor exp .)
    THEN            reduce using rule 41 (exp -> ID xor exp .)
    ,               reduce using rule 41 (exp -> ID xor exp .)
    END             reduce using rule 41 (exp -> ID xor exp .)
    ELSE            reduce using rule 41 (exp -> ID xor exp .)
    ]               reduce using rule 41 (exp -> ID xor exp .)
    [               reduce using rule 41 (exp -> ID xor exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! -               [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! *               [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! DIV             [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! POW             [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! and             [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! imag            [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! CMP             [ reduce using rule 41 (exp -> ID xor exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! IN              [ shift and go to state 27 ]


state 79

    (8) exp -> ID and ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 97
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 80

    (42) exp -> ID and exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 42 (exp -> ID and exp .)
    xor             reduce using rule 42 (exp -> ID and exp .)
    and             reduce using rule 42 (exp -> ID and exp .)
    IN              reduce using rule 42 (exp -> ID and exp .)
    $end            reduce using rule 42 (exp -> ID and exp .)
    )               reduce using rule 42 (exp -> ID and exp .)
    ;               reduce using rule 42 (exp -> ID and exp .)
    }               reduce using rule 42 (exp -> ID and exp .)
    DO              reduce using rule 42 (exp -> ID and exp .)
    THEN            reduce using rule 42 (exp -> ID and exp .)
    ,               reduce using rule 42 (exp -> ID and exp .)
    END             reduce using rule 42 (exp -> ID and exp .)
    ELSE            reduce using rule 42 (exp -> ID and exp .)
    ]               reduce using rule 42 (exp -> ID and exp .)
    [               reduce using rule 42 (exp -> ID and exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 42 (exp -> ID and exp .) ]
  ! -               [ reduce using rule 42 (exp -> ID and exp .) ]
  ! *               [ reduce using rule 42 (exp -> ID and exp .) ]
  ! DIV             [ reduce using rule 42 (exp -> ID and exp .) ]
  ! POW             [ reduce using rule 42 (exp -> ID and exp .) ]
  ! imag            [ reduce using rule 42 (exp -> ID and exp .) ]
  ! CMP             [ reduce using rule 42 (exp -> ID and exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]


state 81

    (20) cmp -> cmp CMP exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    CMP             reduce using rule 20 (cmp -> cmp CMP exp .)
    or              reduce using rule 20 (cmp -> cmp CMP exp .)
    xor             reduce using rule 20 (cmp -> cmp CMP exp .)
    and             reduce using rule 20 (cmp -> cmp CMP exp .)
    IN              reduce using rule 20 (cmp -> cmp CMP exp .)
    $end            reduce using rule 20 (cmp -> cmp CMP exp .)
    )               reduce using rule 20 (cmp -> cmp CMP exp .)
    ;               reduce using rule 20 (cmp -> cmp CMP exp .)
    }               reduce using rule 20 (cmp -> cmp CMP exp .)
    DO              reduce using rule 20 (cmp -> cmp CMP exp .)
    THEN            reduce using rule 20 (cmp -> cmp CMP exp .)
    ,               reduce using rule 20 (cmp -> cmp CMP exp .)
    END             reduce using rule 20 (cmp -> cmp CMP exp .)
    ELSE            reduce using rule 20 (cmp -> cmp CMP exp .)
    ]               reduce using rule 20 (cmp -> cmp CMP exp .)
    [               reduce using rule 20 (cmp -> cmp CMP exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 28

  ! +               [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! -               [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! *               [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! DIV             [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! POW             [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! imag            [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! IN              [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 29 ]


state 82

    (26) exp -> FOR ID IN . it DO exp END
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    [               shift and go to state 17
    ]               shift and go to state 18

    it                             shift and go to state 98

state 83

    (27) exp -> ( exp ) .

    +               reduce using rule 27 (exp -> ( exp ) .)
    -               reduce using rule 27 (exp -> ( exp ) .)
    *               reduce using rule 27 (exp -> ( exp ) .)
    DIV             reduce using rule 27 (exp -> ( exp ) .)
    POW             reduce using rule 27 (exp -> ( exp ) .)
    or              reduce using rule 27 (exp -> ( exp ) .)
    xor             reduce using rule 27 (exp -> ( exp ) .)
    and             reduce using rule 27 (exp -> ( exp ) .)
    IN              reduce using rule 27 (exp -> ( exp ) .)
    imag            reduce using rule 27 (exp -> ( exp ) .)
    CMP             reduce using rule 27 (exp -> ( exp ) .)
    $end            reduce using rule 27 (exp -> ( exp ) .)
    )               reduce using rule 27 (exp -> ( exp ) .)
    ;               reduce using rule 27 (exp -> ( exp ) .)
    }               reduce using rule 27 (exp -> ( exp ) .)
    DO              reduce using rule 27 (exp -> ( exp ) .)
    THEN            reduce using rule 27 (exp -> ( exp ) .)
    ,               reduce using rule 27 (exp -> ( exp ) .)
    END             reduce using rule 27 (exp -> ( exp ) .)
    ELSE            reduce using rule 27 (exp -> ( exp ) .)
    ]               reduce using rule 27 (exp -> ( exp ) .)
    [               reduce using rule 27 (exp -> ( exp ) .)


state 84

    (50) exp -> { seq } .

    +               reduce using rule 50 (exp -> { seq } .)
    -               reduce using rule 50 (exp -> { seq } .)
    *               reduce using rule 50 (exp -> { seq } .)
    DIV             reduce using rule 50 (exp -> { seq } .)
    POW             reduce using rule 50 (exp -> { seq } .)
    or              reduce using rule 50 (exp -> { seq } .)
    xor             reduce using rule 50 (exp -> { seq } .)
    and             reduce using rule 50 (exp -> { seq } .)
    IN              reduce using rule 50 (exp -> { seq } .)
    imag            reduce using rule 50 (exp -> { seq } .)
    CMP             reduce using rule 50 (exp -> { seq } .)
    $end            reduce using rule 50 (exp -> { seq } .)
    )               reduce using rule 50 (exp -> { seq } .)
    ;               reduce using rule 50 (exp -> { seq } .)
    }               reduce using rule 50 (exp -> { seq } .)
    DO              reduce using rule 50 (exp -> { seq } .)
    THEN            reduce using rule 50 (exp -> { seq } .)
    ,               reduce using rule 50 (exp -> { seq } .)
    END             reduce using rule 50 (exp -> { seq } .)
    ELSE            reduce using rule 50 (exp -> { seq } .)
    ]               reduce using rule 50 (exp -> { seq } .)
    [               reduce using rule 50 (exp -> { seq } .)


state 85

    (47) seq -> exp ; . seq
    (48) seq -> exp ; .
    (47) seq -> . exp ; seq
    (48) seq -> . exp ;
    (49) seq -> . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    }               reduce using rule 48 (seq -> exp ; .)
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 49
    seq                            shift and go to state 99
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 86

    (54) exp -> WHILE exp DO . exp END
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 100
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 87

    (22) ifc -> IF exp THEN . exp
    (23) ifc -> IF exp THEN . exp ELSE exp
    (24) ifc -> IF exp THEN . exp ELSE ifc
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 101
    ifc                            shift and go to state 6
    cmp                            shift and go to state 5
    it                             shift and go to state 8

state 88

    (29) it -> [ exp , . exp ]
    (31) it -> [ exp , . exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 102
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 89

    (30) it -> ] exp , . exp ]
    (32) it -> ] exp , . exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 103
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 90

    (1) exp -> ID + ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 1 (exp -> ID + ASG exp .)
    $end            reduce using rule 1 (exp -> ID + ASG exp .)
    )               reduce using rule 1 (exp -> ID + ASG exp .)
    ;               reduce using rule 1 (exp -> ID + ASG exp .)
    }               reduce using rule 1 (exp -> ID + ASG exp .)
    DO              reduce using rule 1 (exp -> ID + ASG exp .)
    THEN            reduce using rule 1 (exp -> ID + ASG exp .)
    ,               reduce using rule 1 (exp -> ID + ASG exp .)
    END             reduce using rule 1 (exp -> ID + ASG exp .)
    ELSE            reduce using rule 1 (exp -> ID + ASG exp .)
    ]               reduce using rule 1 (exp -> ID + ASG exp .)
    [               reduce using rule 1 (exp -> ID + ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! -               [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! *               [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! DIV             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! POW             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! or              [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! xor             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! and             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! imag            [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! CMP             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 91

    (2) exp -> ID - ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 2 (exp -> ID - ASG exp .)
    $end            reduce using rule 2 (exp -> ID - ASG exp .)
    )               reduce using rule 2 (exp -> ID - ASG exp .)
    ;               reduce using rule 2 (exp -> ID - ASG exp .)
    }               reduce using rule 2 (exp -> ID - ASG exp .)
    DO              reduce using rule 2 (exp -> ID - ASG exp .)
    THEN            reduce using rule 2 (exp -> ID - ASG exp .)
    ,               reduce using rule 2 (exp -> ID - ASG exp .)
    END             reduce using rule 2 (exp -> ID - ASG exp .)
    ELSE            reduce using rule 2 (exp -> ID - ASG exp .)
    ]               reduce using rule 2 (exp -> ID - ASG exp .)
    [               reduce using rule 2 (exp -> ID - ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! -               [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! *               [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! DIV             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! POW             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! or              [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! xor             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! and             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! imag            [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! CMP             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 92

    (3) exp -> ID * ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 3 (exp -> ID * ASG exp .)
    $end            reduce using rule 3 (exp -> ID * ASG exp .)
    )               reduce using rule 3 (exp -> ID * ASG exp .)
    ;               reduce using rule 3 (exp -> ID * ASG exp .)
    }               reduce using rule 3 (exp -> ID * ASG exp .)
    DO              reduce using rule 3 (exp -> ID * ASG exp .)
    THEN            reduce using rule 3 (exp -> ID * ASG exp .)
    ,               reduce using rule 3 (exp -> ID * ASG exp .)
    END             reduce using rule 3 (exp -> ID * ASG exp .)
    ELSE            reduce using rule 3 (exp -> ID * ASG exp .)
    ]               reduce using rule 3 (exp -> ID * ASG exp .)
    [               reduce using rule 3 (exp -> ID * ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! -               [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! *               [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! DIV             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! POW             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! or              [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! xor             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! and             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! imag            [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! CMP             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 93

    (4) exp -> ID DIV ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 4 (exp -> ID DIV ASG exp .)
    $end            reduce using rule 4 (exp -> ID DIV ASG exp .)
    )               reduce using rule 4 (exp -> ID DIV ASG exp .)
    ;               reduce using rule 4 (exp -> ID DIV ASG exp .)
    }               reduce using rule 4 (exp -> ID DIV ASG exp .)
    DO              reduce using rule 4 (exp -> ID DIV ASG exp .)
    THEN            reduce using rule 4 (exp -> ID DIV ASG exp .)
    ,               reduce using rule 4 (exp -> ID DIV ASG exp .)
    END             reduce using rule 4 (exp -> ID DIV ASG exp .)
    ELSE            reduce using rule 4 (exp -> ID DIV ASG exp .)
    ]               reduce using rule 4 (exp -> ID DIV ASG exp .)
    [               reduce using rule 4 (exp -> ID DIV ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! -               [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! *               [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! DIV             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! POW             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! or              [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! xor             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! and             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! imag            [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! CMP             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 94

    (5) exp -> ID POW ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 5 (exp -> ID POW ASG exp .)
    $end            reduce using rule 5 (exp -> ID POW ASG exp .)
    )               reduce using rule 5 (exp -> ID POW ASG exp .)
    ;               reduce using rule 5 (exp -> ID POW ASG exp .)
    }               reduce using rule 5 (exp -> ID POW ASG exp .)
    DO              reduce using rule 5 (exp -> ID POW ASG exp .)
    THEN            reduce using rule 5 (exp -> ID POW ASG exp .)
    ,               reduce using rule 5 (exp -> ID POW ASG exp .)
    END             reduce using rule 5 (exp -> ID POW ASG exp .)
    ELSE            reduce using rule 5 (exp -> ID POW ASG exp .)
    ]               reduce using rule 5 (exp -> ID POW ASG exp .)
    [               reduce using rule 5 (exp -> ID POW ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! -               [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! *               [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! DIV             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! POW             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! or              [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! xor             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! and             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! imag            [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! CMP             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 95

    (6) exp -> ID or ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 6 (exp -> ID or ASG exp .)
    $end            reduce using rule 6 (exp -> ID or ASG exp .)
    )               reduce using rule 6 (exp -> ID or ASG exp .)
    ;               reduce using rule 6 (exp -> ID or ASG exp .)
    }               reduce using rule 6 (exp -> ID or ASG exp .)
    DO              reduce using rule 6 (exp -> ID or ASG exp .)
    THEN            reduce using rule 6 (exp -> ID or ASG exp .)
    ,               reduce using rule 6 (exp -> ID or ASG exp .)
    END             reduce using rule 6 (exp -> ID or ASG exp .)
    ELSE            reduce using rule 6 (exp -> ID or ASG exp .)
    ]               reduce using rule 6 (exp -> ID or ASG exp .)
    [               reduce using rule 6 (exp -> ID or ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! -               [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! *               [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! DIV             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! POW             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! or              [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! xor             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! and             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! imag            [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! CMP             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 96

    (7) exp -> ID xor ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 7 (exp -> ID xor ASG exp .)
    $end            reduce using rule 7 (exp -> ID xor ASG exp .)
    )               reduce using rule 7 (exp -> ID xor ASG exp .)
    ;               reduce using rule 7 (exp -> ID xor ASG exp .)
    }               reduce using rule 7 (exp -> ID xor ASG exp .)
    DO              reduce using rule 7 (exp -> ID xor ASG exp .)
    THEN            reduce using rule 7 (exp -> ID xor ASG exp .)
    ,               reduce using rule 7 (exp -> ID xor ASG exp .)
    END             reduce using rule 7 (exp -> ID xor ASG exp .)
    ELSE            reduce using rule 7 (exp -> ID xor ASG exp .)
    ]               reduce using rule 7 (exp -> ID xor ASG exp .)
    [               reduce using rule 7 (exp -> ID xor ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! -               [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! *               [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! DIV             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! POW             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! or              [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! xor             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! and             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! imag            [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! CMP             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 97

    (8) exp -> ID and ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    IN              reduce using rule 8 (exp -> ID and ASG exp .)
    $end            reduce using rule 8 (exp -> ID and ASG exp .)
    )               reduce using rule 8 (exp -> ID and ASG exp .)
    ;               reduce using rule 8 (exp -> ID and ASG exp .)
    }               reduce using rule 8 (exp -> ID and ASG exp .)
    DO              reduce using rule 8 (exp -> ID and ASG exp .)
    THEN            reduce using rule 8 (exp -> ID and ASG exp .)
    ,               reduce using rule 8 (exp -> ID and ASG exp .)
    END             reduce using rule 8 (exp -> ID and ASG exp .)
    ELSE            reduce using rule 8 (exp -> ID and ASG exp .)
    ]               reduce using rule 8 (exp -> ID and ASG exp .)
    [               reduce using rule 8 (exp -> ID and ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 28
    CMP             shift and go to state 29

  ! +               [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! -               [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! *               [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! DIV             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! POW             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! or              [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! xor             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! and             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! imag            [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! CMP             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! IN              [ shift and go to state 27 ]


state 98

    (26) exp -> FOR ID IN it . DO exp END

    DO              shift and go to state 104


state 99

    (47) seq -> exp ; seq .

    }               reduce using rule 47 (seq -> exp ; seq .)


state 100

    (54) exp -> WHILE exp DO exp . END
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             shift and go to state 105
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 101

    (22) ifc -> IF exp THEN exp .
    (23) ifc -> IF exp THEN exp . ELSE exp
    (24) ifc -> IF exp THEN exp . ELSE ifc
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             reduce using rule 22 (ifc -> IF exp THEN exp .)
    ELSE            shift and go to state 106
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 102

    (29) it -> [ exp , exp . ]
    (31) it -> [ exp , exp . [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ]               shift and go to state 108
    [               shift and go to state 107
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 103

    (30) it -> ] exp , exp . ]
    (32) it -> ] exp , exp . [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ]               shift and go to state 109
    [               shift and go to state 110
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 104

    (26) exp -> FOR ID IN it DO . exp END
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    it                             shift and go to state 8
    exp                            shift and go to state 111
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6

state 105

    (54) exp -> WHILE exp DO exp END .

    +               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    -               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    *               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    DIV             reduce using rule 54 (exp -> WHILE exp DO exp END .)
    POW             reduce using rule 54 (exp -> WHILE exp DO exp END .)
    or              reduce using rule 54 (exp -> WHILE exp DO exp END .)
    xor             reduce using rule 54 (exp -> WHILE exp DO exp END .)
    and             reduce using rule 54 (exp -> WHILE exp DO exp END .)
    IN              reduce using rule 54 (exp -> WHILE exp DO exp END .)
    imag            reduce using rule 54 (exp -> WHILE exp DO exp END .)
    CMP             reduce using rule 54 (exp -> WHILE exp DO exp END .)
    $end            reduce using rule 54 (exp -> WHILE exp DO exp END .)
    )               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    ;               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    }               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    DO              reduce using rule 54 (exp -> WHILE exp DO exp END .)
    THEN            reduce using rule 54 (exp -> WHILE exp DO exp END .)
    ,               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    END             reduce using rule 54 (exp -> WHILE exp DO exp END .)
    ELSE            reduce using rule 54 (exp -> WHILE exp DO exp END .)
    ]               reduce using rule 54 (exp -> WHILE exp DO exp END .)
    [               reduce using rule 54 (exp -> WHILE exp DO exp END .)


state 106

    (23) ifc -> IF exp THEN exp ELSE . exp
    (24) ifc -> IF exp THEN exp ELSE . ifc
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . exp IN it
    (35) exp -> . ID + exp
    (36) exp -> . ID - exp
    (37) exp -> . ID * exp
    (38) exp -> . ID DIV exp
    (39) exp -> . ID POW exp
    (40) exp -> . ID or exp
    (41) exp -> . ID xor exp
    (42) exp -> . ID and exp
    (43) exp -> . + exp
    (44) exp -> . - exp
    (45) exp -> . not exp
    (46) exp -> . SYS exp
    (50) exp -> . { seq }
    (51) exp -> . STR
    (52) exp -> . exp imag
    (53) exp -> . NUM
    (54) exp -> . WHILE exp DO exp END
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 112
    ifc                            shift and go to state 113
    cmp                            shift and go to state 5
    it                             shift and go to state 8

state 107

    (31) it -> [ exp , exp [ .

    +               reduce using rule 31 (it -> [ exp , exp [ .)
    -               reduce using rule 31 (it -> [ exp , exp [ .)
    *               reduce using rule 31 (it -> [ exp , exp [ .)
    DIV             reduce using rule 31 (it -> [ exp , exp [ .)
    POW             reduce using rule 31 (it -> [ exp , exp [ .)
    or              reduce using rule 31 (it -> [ exp , exp [ .)
    xor             reduce using rule 31 (it -> [ exp , exp [ .)
    and             reduce using rule 31 (it -> [ exp , exp [ .)
    IN              reduce using rule 31 (it -> [ exp , exp [ .)
    imag            reduce using rule 31 (it -> [ exp , exp [ .)
    CMP             reduce using rule 31 (it -> [ exp , exp [ .)
    $end            reduce using rule 31 (it -> [ exp , exp [ .)
    )               reduce using rule 31 (it -> [ exp , exp [ .)
    ;               reduce using rule 31 (it -> [ exp , exp [ .)
    }               reduce using rule 31 (it -> [ exp , exp [ .)
    DO              reduce using rule 31 (it -> [ exp , exp [ .)
    THEN            reduce using rule 31 (it -> [ exp , exp [ .)
    ,               reduce using rule 31 (it -> [ exp , exp [ .)
    END             reduce using rule 31 (it -> [ exp , exp [ .)
    ELSE            reduce using rule 31 (it -> [ exp , exp [ .)
    ]               reduce using rule 31 (it -> [ exp , exp [ .)
    [               reduce using rule 31 (it -> [ exp , exp [ .)


state 108

    (29) it -> [ exp , exp ] .

    +               reduce using rule 29 (it -> [ exp , exp ] .)
    -               reduce using rule 29 (it -> [ exp , exp ] .)
    *               reduce using rule 29 (it -> [ exp , exp ] .)
    DIV             reduce using rule 29 (it -> [ exp , exp ] .)
    POW             reduce using rule 29 (it -> [ exp , exp ] .)
    or              reduce using rule 29 (it -> [ exp , exp ] .)
    xor             reduce using rule 29 (it -> [ exp , exp ] .)
    and             reduce using rule 29 (it -> [ exp , exp ] .)
    IN              reduce using rule 29 (it -> [ exp , exp ] .)
    imag            reduce using rule 29 (it -> [ exp , exp ] .)
    CMP             reduce using rule 29 (it -> [ exp , exp ] .)
    $end            reduce using rule 29 (it -> [ exp , exp ] .)
    )               reduce using rule 29 (it -> [ exp , exp ] .)
    ;               reduce using rule 29 (it -> [ exp , exp ] .)
    }               reduce using rule 29 (it -> [ exp , exp ] .)
    DO              reduce using rule 29 (it -> [ exp , exp ] .)
    THEN            reduce using rule 29 (it -> [ exp , exp ] .)
    ,               reduce using rule 29 (it -> [ exp , exp ] .)
    END             reduce using rule 29 (it -> [ exp , exp ] .)
    ELSE            reduce using rule 29 (it -> [ exp , exp ] .)
    ]               reduce using rule 29 (it -> [ exp , exp ] .)
    [               reduce using rule 29 (it -> [ exp , exp ] .)


state 109

    (30) it -> ] exp , exp ] .

    +               reduce using rule 30 (it -> ] exp , exp ] .)
    -               reduce using rule 30 (it -> ] exp , exp ] .)
    *               reduce using rule 30 (it -> ] exp , exp ] .)
    DIV             reduce using rule 30 (it -> ] exp , exp ] .)
    POW             reduce using rule 30 (it -> ] exp , exp ] .)
    or              reduce using rule 30 (it -> ] exp , exp ] .)
    xor             reduce using rule 30 (it -> ] exp , exp ] .)
    and             reduce using rule 30 (it -> ] exp , exp ] .)
    IN              reduce using rule 30 (it -> ] exp , exp ] .)
    imag            reduce using rule 30 (it -> ] exp , exp ] .)
    CMP             reduce using rule 30 (it -> ] exp , exp ] .)
    $end            reduce using rule 30 (it -> ] exp , exp ] .)
    )               reduce using rule 30 (it -> ] exp , exp ] .)
    ;               reduce using rule 30 (it -> ] exp , exp ] .)
    }               reduce using rule 30 (it -> ] exp , exp ] .)
    DO              reduce using rule 30 (it -> ] exp , exp ] .)
    THEN            reduce using rule 30 (it -> ] exp , exp ] .)
    ,               reduce using rule 30 (it -> ] exp , exp ] .)
    END             reduce using rule 30 (it -> ] exp , exp ] .)
    ELSE            reduce using rule 30 (it -> ] exp , exp ] .)
    ]               reduce using rule 30 (it -> ] exp , exp ] .)
    [               reduce using rule 30 (it -> ] exp , exp ] .)


state 110

    (32) it -> ] exp , exp [ .

    +               reduce using rule 32 (it -> ] exp , exp [ .)
    -               reduce using rule 32 (it -> ] exp , exp [ .)
    *               reduce using rule 32 (it -> ] exp , exp [ .)
    DIV             reduce using rule 32 (it -> ] exp , exp [ .)
    POW             reduce using rule 32 (it -> ] exp , exp [ .)
    or              reduce using rule 32 (it -> ] exp , exp [ .)
    xor             reduce using rule 32 (it -> ] exp , exp [ .)
    and             reduce using rule 32 (it -> ] exp , exp [ .)
    IN              reduce using rule 32 (it -> ] exp , exp [ .)
    imag            reduce using rule 32 (it -> ] exp , exp [ .)
    CMP             reduce using rule 32 (it -> ] exp , exp [ .)
    $end            reduce using rule 32 (it -> ] exp , exp [ .)
    )               reduce using rule 32 (it -> ] exp , exp [ .)
    ;               reduce using rule 32 (it -> ] exp , exp [ .)
    }               reduce using rule 32 (it -> ] exp , exp [ .)
    DO              reduce using rule 32 (it -> ] exp , exp [ .)
    THEN            reduce using rule 32 (it -> ] exp , exp [ .)
    ,               reduce using rule 32 (it -> ] exp , exp [ .)
    END             reduce using rule 32 (it -> ] exp , exp [ .)
    ELSE            reduce using rule 32 (it -> ] exp , exp [ .)
    ]               reduce using rule 32 (it -> ] exp , exp [ .)
    [               reduce using rule 32 (it -> ] exp , exp [ .)


state 111

    (26) exp -> FOR ID IN it DO exp . END
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             shift and go to state 114
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 112

    (23) ifc -> IF exp THEN exp ELSE exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (34) exp -> exp . IN it
    (52) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             reduce using rule 23 (ifc -> IF exp THEN exp ELSE exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    IN              shift and go to state 27
    imag            shift and go to state 28
    CMP             shift and go to state 29


state 113

    (24) ifc -> IF exp THEN exp ELSE ifc .
    (25) exp -> ifc . END

    END             reduce using rule 24 (ifc -> IF exp THEN exp ELSE ifc .)

  ! END             [ shift and go to state 43 ]


state 114

    (26) exp -> FOR ID IN it DO exp END .

    +               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    -               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    *               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    DIV             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    POW             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    or              reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    xor             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    and             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    IN              reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    imag            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    CMP             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    $end            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    )               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ;               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    }               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    DO              reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    THEN            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ,               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    END             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ELSE            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ]               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    [               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)

