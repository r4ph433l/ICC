Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> exp
Rule 1     exp -> ID + ASG exp
Rule 2     exp -> ID - ASG exp
Rule 3     exp -> ID * ASG exp
Rule 4     exp -> ID DIV ASG exp
Rule 5     exp -> ID POW ASG exp
Rule 6     exp -> ID or ASG exp
Rule 7     exp -> ID xor ASG exp
Rule 8     exp -> ID and ASG exp
Rule 9     exp -> ID ASG exp
Rule 10    exp -> ID USG
Rule 11    exp -> exp + exp
Rule 12    exp -> exp - exp
Rule 13    exp -> exp * exp
Rule 14    exp -> exp DIV exp
Rule 15    exp -> exp POW exp
Rule 16    exp -> exp or exp
Rule 17    exp -> exp xor exp
Rule 18    exp -> exp and exp
Rule 19    cmp -> exp CMP exp
Rule 20    cmp -> cmp CMP exp
Rule 21    exp -> cmp
Rule 22    ifc -> IF exp THEN exp
Rule 23    ifc -> IF exp THEN exp ELSE exp
Rule 24    ifc -> IF exp THEN exp ELSE ifc
Rule 25    exp -> ifc END
Rule 26    exp -> FOR ID IN it DO exp END
Rule 27    exp -> ( exp )
Rule 28    exp -> ID
Rule 29    it -> [ exp , exp ]
Rule 30    it -> ] exp , exp ]
Rule 31    it -> [ exp , exp [
Rule 32    it -> ] exp , exp [
Rule 33    exp -> it
Rule 34    exp -> ID + exp
Rule 35    exp -> ID - exp
Rule 36    exp -> ID * exp
Rule 37    exp -> ID DIV exp
Rule 38    exp -> ID POW exp
Rule 39    exp -> ID or exp
Rule 40    exp -> ID xor exp
Rule 41    exp -> ID and exp
Rule 42    exp -> + exp
Rule 43    exp -> - exp
Rule 44    exp -> not exp
Rule 45    exp -> SYS exp
Rule 46    seq -> exp ; seq
Rule 47    seq -> exp ;
Rule 48    seq -> exp
Rule 49    exp -> { seq }
Rule 50    exp -> STR
Rule 51    exp -> exp imag
Rule 52    exp -> NUM
Rule 53    exp -> WHILE exp DO exp END

Terminals, with rules where they appear

(                    : 27
)                    : 27
*                    : 3 13 36
+                    : 1 11 34 42
,                    : 29 30 31 32
-                    : 2 12 35 43
;                    : 46 47
ASG                  : 1 2 3 4 5 6 7 8 9
CMP                  : 19 20
DIV                  : 4 14 37
DO                   : 26 53
ELSE                 : 23 24
END                  : 25 26 53
FOR                  : 26
ID                   : 1 2 3 4 5 6 7 8 9 10 26 28 34 35 36 37 38 39 40 41
IF                   : 22 23 24
IN                   : 26
NUM                  : 52
POW                  : 5 15 38
STR                  : 50
SYS                  : 45
THEN                 : 22 23 24
USG                  : 10
WHILE                : 53
[                    : 29 31 31 32
]                    : 29 30 30 32
and                  : 8 18 41
error                : 
imag                 : 51
not                  : 44
or                   : 6 16 39
xor                  : 7 17 40
{                    : 49
}                    : 49

Nonterminals, with rules where they appear

cmp                  : 20 21
exp                  : 1 2 3 4 5 6 7 8 9 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 22 22 23 23 23 24 24 26 27 29 29 30 30 31 31 32 32 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 51 53 53 0
ifc                  : 24 25
it                   : 26 33
seq                  : 46 49

Parsing method: LALR

state 0

    (0) S' -> . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 1
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 1

    (0) S' -> exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 2

    (1) exp -> ID . + ASG exp
    (2) exp -> ID . - ASG exp
    (3) exp -> ID . * ASG exp
    (4) exp -> ID . DIV ASG exp
    (5) exp -> ID . POW ASG exp
    (6) exp -> ID . or ASG exp
    (7) exp -> ID . xor ASG exp
    (8) exp -> ID . and ASG exp
    (9) exp -> ID . ASG exp
    (10) exp -> ID . USG
    (28) exp -> ID .
    (34) exp -> ID . + exp
    (35) exp -> ID . - exp
    (36) exp -> ID . * exp
    (37) exp -> ID . DIV exp
    (38) exp -> ID . POW exp
    (39) exp -> ID . or exp
    (40) exp -> ID . xor exp
    (41) exp -> ID . and exp

    +               shift and go to state 29
    -               shift and go to state 31
    *               shift and go to state 32
    DIV             shift and go to state 33
    POW             shift and go to state 34
    or              shift and go to state 35
    xor             shift and go to state 36
    and             shift and go to state 37
    ASG             shift and go to state 30
    USG             shift and go to state 38
    imag            reduce using rule 28 (exp -> ID .)
    CMP             reduce using rule 28 (exp -> ID .)
    $end            reduce using rule 28 (exp -> ID .)
    )               reduce using rule 28 (exp -> ID .)
    ;               reduce using rule 28 (exp -> ID .)
    }               reduce using rule 28 (exp -> ID .)
    DO              reduce using rule 28 (exp -> ID .)
    THEN            reduce using rule 28 (exp -> ID .)
    ,               reduce using rule 28 (exp -> ID .)
    END             reduce using rule 28 (exp -> ID .)
    ELSE            reduce using rule 28 (exp -> ID .)
    ]               reduce using rule 28 (exp -> ID .)
    [               reduce using rule 28 (exp -> ID .)

  ! +               [ reduce using rule 28 (exp -> ID .) ]
  ! -               [ reduce using rule 28 (exp -> ID .) ]
  ! *               [ reduce using rule 28 (exp -> ID .) ]
  ! DIV             [ reduce using rule 28 (exp -> ID .) ]
  ! POW             [ reduce using rule 28 (exp -> ID .) ]
  ! or              [ reduce using rule 28 (exp -> ID .) ]
  ! xor             [ reduce using rule 28 (exp -> ID .) ]
  ! and             [ reduce using rule 28 (exp -> ID .) ]


state 3

    (42) exp -> + . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 39
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 4

    (43) exp -> - . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 40
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 5

    (21) exp -> cmp .
    (20) cmp -> cmp . CMP exp

    +               reduce using rule 21 (exp -> cmp .)
    -               reduce using rule 21 (exp -> cmp .)
    *               reduce using rule 21 (exp -> cmp .)
    DIV             reduce using rule 21 (exp -> cmp .)
    POW             reduce using rule 21 (exp -> cmp .)
    or              reduce using rule 21 (exp -> cmp .)
    xor             reduce using rule 21 (exp -> cmp .)
    and             reduce using rule 21 (exp -> cmp .)
    imag            reduce using rule 21 (exp -> cmp .)
    $end            reduce using rule 21 (exp -> cmp .)
    )               reduce using rule 21 (exp -> cmp .)
    ;               reduce using rule 21 (exp -> cmp .)
    }               reduce using rule 21 (exp -> cmp .)
    DO              reduce using rule 21 (exp -> cmp .)
    THEN            reduce using rule 21 (exp -> cmp .)
    ,               reduce using rule 21 (exp -> cmp .)
    END             reduce using rule 21 (exp -> cmp .)
    ELSE            reduce using rule 21 (exp -> cmp .)
    ]               reduce using rule 21 (exp -> cmp .)
    [               reduce using rule 21 (exp -> cmp .)
    CMP             shift and go to state 41

  ! CMP             [ reduce using rule 21 (exp -> cmp .) ]


state 6

    (25) exp -> ifc . END

    END             shift and go to state 42


state 7

    (26) exp -> FOR . ID IN it DO exp END

    ID              shift and go to state 43


state 8

    (33) exp -> it .

    +               reduce using rule 33 (exp -> it .)
    -               reduce using rule 33 (exp -> it .)
    *               reduce using rule 33 (exp -> it .)
    DIV             reduce using rule 33 (exp -> it .)
    POW             reduce using rule 33 (exp -> it .)
    or              reduce using rule 33 (exp -> it .)
    xor             reduce using rule 33 (exp -> it .)
    and             reduce using rule 33 (exp -> it .)
    imag            reduce using rule 33 (exp -> it .)
    CMP             reduce using rule 33 (exp -> it .)
    $end            reduce using rule 33 (exp -> it .)
    )               reduce using rule 33 (exp -> it .)
    ;               reduce using rule 33 (exp -> it .)
    }               reduce using rule 33 (exp -> it .)
    DO              reduce using rule 33 (exp -> it .)
    THEN            reduce using rule 33 (exp -> it .)
    ,               reduce using rule 33 (exp -> it .)
    END             reduce using rule 33 (exp -> it .)
    ELSE            reduce using rule 33 (exp -> it .)
    ]               reduce using rule 33 (exp -> it .)
    [               reduce using rule 33 (exp -> it .)


state 9

    (27) exp -> ( . exp )
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 44
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 10

    (44) exp -> not . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 45
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 11

    (45) exp -> SYS . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 46
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 12

    (49) exp -> { . seq }
    (46) seq -> . exp ; seq
    (47) seq -> . exp ;
    (48) seq -> . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    seq                            shift and go to state 47
    exp                            shift and go to state 48
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 13

    (50) exp -> STR .

    +               reduce using rule 50 (exp -> STR .)
    -               reduce using rule 50 (exp -> STR .)
    *               reduce using rule 50 (exp -> STR .)
    DIV             reduce using rule 50 (exp -> STR .)
    POW             reduce using rule 50 (exp -> STR .)
    or              reduce using rule 50 (exp -> STR .)
    xor             reduce using rule 50 (exp -> STR .)
    and             reduce using rule 50 (exp -> STR .)
    imag            reduce using rule 50 (exp -> STR .)
    CMP             reduce using rule 50 (exp -> STR .)
    $end            reduce using rule 50 (exp -> STR .)
    )               reduce using rule 50 (exp -> STR .)
    ;               reduce using rule 50 (exp -> STR .)
    }               reduce using rule 50 (exp -> STR .)
    DO              reduce using rule 50 (exp -> STR .)
    THEN            reduce using rule 50 (exp -> STR .)
    ,               reduce using rule 50 (exp -> STR .)
    END             reduce using rule 50 (exp -> STR .)
    ELSE            reduce using rule 50 (exp -> STR .)
    ]               reduce using rule 50 (exp -> STR .)
    [               reduce using rule 50 (exp -> STR .)


state 14

    (52) exp -> NUM .

    +               reduce using rule 52 (exp -> NUM .)
    -               reduce using rule 52 (exp -> NUM .)
    *               reduce using rule 52 (exp -> NUM .)
    DIV             reduce using rule 52 (exp -> NUM .)
    POW             reduce using rule 52 (exp -> NUM .)
    or              reduce using rule 52 (exp -> NUM .)
    xor             reduce using rule 52 (exp -> NUM .)
    and             reduce using rule 52 (exp -> NUM .)
    imag            reduce using rule 52 (exp -> NUM .)
    CMP             reduce using rule 52 (exp -> NUM .)
    $end            reduce using rule 52 (exp -> NUM .)
    )               reduce using rule 52 (exp -> NUM .)
    ;               reduce using rule 52 (exp -> NUM .)
    }               reduce using rule 52 (exp -> NUM .)
    DO              reduce using rule 52 (exp -> NUM .)
    THEN            reduce using rule 52 (exp -> NUM .)
    ,               reduce using rule 52 (exp -> NUM .)
    END             reduce using rule 52 (exp -> NUM .)
    ELSE            reduce using rule 52 (exp -> NUM .)
    ]               reduce using rule 52 (exp -> NUM .)
    [               reduce using rule 52 (exp -> NUM .)


state 15

    (53) exp -> WHILE . exp DO exp END
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 49
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 16

    (22) ifc -> IF . exp THEN exp
    (23) ifc -> IF . exp THEN exp ELSE exp
    (24) ifc -> IF . exp THEN exp ELSE ifc
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 50
    ifc                            shift and go to state 6
    cmp                            shift and go to state 5
    it                             shift and go to state 8

state 17

    (29) it -> [ . exp , exp ]
    (31) it -> [ . exp , exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 51
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 18

    (30) it -> ] . exp , exp ]
    (32) it -> ] . exp , exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 52
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 19

    (11) exp -> exp + . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 53
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 20

    (12) exp -> exp - . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 54
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 21

    (13) exp -> exp * . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 55
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 22

    (14) exp -> exp DIV . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 56
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 23

    (15) exp -> exp POW . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 57
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 24

    (16) exp -> exp or . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 58
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 25

    (17) exp -> exp xor . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 59
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 26

    (18) exp -> exp and . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 60
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 27

    (51) exp -> exp imag .

    +               reduce using rule 51 (exp -> exp imag .)
    -               reduce using rule 51 (exp -> exp imag .)
    *               reduce using rule 51 (exp -> exp imag .)
    DIV             reduce using rule 51 (exp -> exp imag .)
    POW             reduce using rule 51 (exp -> exp imag .)
    or              reduce using rule 51 (exp -> exp imag .)
    xor             reduce using rule 51 (exp -> exp imag .)
    and             reduce using rule 51 (exp -> exp imag .)
    imag            reduce using rule 51 (exp -> exp imag .)
    CMP             reduce using rule 51 (exp -> exp imag .)
    $end            reduce using rule 51 (exp -> exp imag .)
    )               reduce using rule 51 (exp -> exp imag .)
    ;               reduce using rule 51 (exp -> exp imag .)
    }               reduce using rule 51 (exp -> exp imag .)
    DO              reduce using rule 51 (exp -> exp imag .)
    THEN            reduce using rule 51 (exp -> exp imag .)
    ,               reduce using rule 51 (exp -> exp imag .)
    END             reduce using rule 51 (exp -> exp imag .)
    ELSE            reduce using rule 51 (exp -> exp imag .)
    ]               reduce using rule 51 (exp -> exp imag .)
    [               reduce using rule 51 (exp -> exp imag .)


state 28

    (19) cmp -> exp CMP . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 61
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 29

    (1) exp -> ID + . ASG exp
    (34) exp -> ID + . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 62
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 63
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 30

    (9) exp -> ID ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 64
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 31

    (2) exp -> ID - . ASG exp
    (35) exp -> ID - . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 65
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 66
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 32

    (3) exp -> ID * . ASG exp
    (36) exp -> ID * . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 67
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 68
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 33

    (4) exp -> ID DIV . ASG exp
    (37) exp -> ID DIV . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 69
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 70
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 34

    (5) exp -> ID POW . ASG exp
    (38) exp -> ID POW . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 71
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 72
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 35

    (6) exp -> ID or . ASG exp
    (39) exp -> ID or . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 73
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 74
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 36

    (7) exp -> ID xor . ASG exp
    (40) exp -> ID xor . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 75
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 76
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 37

    (8) exp -> ID and . ASG exp
    (41) exp -> ID and . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ASG             shift and go to state 77
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 78
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 38

    (10) exp -> ID USG .

    +               reduce using rule 10 (exp -> ID USG .)
    -               reduce using rule 10 (exp -> ID USG .)
    *               reduce using rule 10 (exp -> ID USG .)
    DIV             reduce using rule 10 (exp -> ID USG .)
    POW             reduce using rule 10 (exp -> ID USG .)
    or              reduce using rule 10 (exp -> ID USG .)
    xor             reduce using rule 10 (exp -> ID USG .)
    and             reduce using rule 10 (exp -> ID USG .)
    imag            reduce using rule 10 (exp -> ID USG .)
    CMP             reduce using rule 10 (exp -> ID USG .)
    $end            reduce using rule 10 (exp -> ID USG .)
    )               reduce using rule 10 (exp -> ID USG .)
    ;               reduce using rule 10 (exp -> ID USG .)
    }               reduce using rule 10 (exp -> ID USG .)
    DO              reduce using rule 10 (exp -> ID USG .)
    THEN            reduce using rule 10 (exp -> ID USG .)
    ,               reduce using rule 10 (exp -> ID USG .)
    END             reduce using rule 10 (exp -> ID USG .)
    ELSE            reduce using rule 10 (exp -> ID USG .)
    ]               reduce using rule 10 (exp -> ID USG .)
    [               reduce using rule 10 (exp -> ID USG .)


state 39

    (42) exp -> + exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 42 (exp -> + exp .)
    -               reduce using rule 42 (exp -> + exp .)
    or              reduce using rule 42 (exp -> + exp .)
    xor             reduce using rule 42 (exp -> + exp .)
    and             reduce using rule 42 (exp -> + exp .)
    CMP             reduce using rule 42 (exp -> + exp .)
    $end            reduce using rule 42 (exp -> + exp .)
    )               reduce using rule 42 (exp -> + exp .)
    ;               reduce using rule 42 (exp -> + exp .)
    }               reduce using rule 42 (exp -> + exp .)
    DO              reduce using rule 42 (exp -> + exp .)
    THEN            reduce using rule 42 (exp -> + exp .)
    ,               reduce using rule 42 (exp -> + exp .)
    END             reduce using rule 42 (exp -> + exp .)
    ELSE            reduce using rule 42 (exp -> + exp .)
    ]               reduce using rule 42 (exp -> + exp .)
    [               reduce using rule 42 (exp -> + exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! *               [ reduce using rule 42 (exp -> + exp .) ]
  ! DIV             [ reduce using rule 42 (exp -> + exp .) ]
  ! POW             [ reduce using rule 42 (exp -> + exp .) ]
  ! imag            [ reduce using rule 42 (exp -> + exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 40

    (43) exp -> - exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 43 (exp -> - exp .)
    -               reduce using rule 43 (exp -> - exp .)
    or              reduce using rule 43 (exp -> - exp .)
    xor             reduce using rule 43 (exp -> - exp .)
    and             reduce using rule 43 (exp -> - exp .)
    CMP             reduce using rule 43 (exp -> - exp .)
    $end            reduce using rule 43 (exp -> - exp .)
    )               reduce using rule 43 (exp -> - exp .)
    ;               reduce using rule 43 (exp -> - exp .)
    }               reduce using rule 43 (exp -> - exp .)
    DO              reduce using rule 43 (exp -> - exp .)
    THEN            reduce using rule 43 (exp -> - exp .)
    ,               reduce using rule 43 (exp -> - exp .)
    END             reduce using rule 43 (exp -> - exp .)
    ELSE            reduce using rule 43 (exp -> - exp .)
    ]               reduce using rule 43 (exp -> - exp .)
    [               reduce using rule 43 (exp -> - exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! *               [ reduce using rule 43 (exp -> - exp .) ]
  ! DIV             [ reduce using rule 43 (exp -> - exp .) ]
  ! POW             [ reduce using rule 43 (exp -> - exp .) ]
  ! imag            [ reduce using rule 43 (exp -> - exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 41

    (20) cmp -> cmp CMP . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    cmp                            shift and go to state 5
    exp                            shift and go to state 79
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 42

    (25) exp -> ifc END .

    +               reduce using rule 25 (exp -> ifc END .)
    -               reduce using rule 25 (exp -> ifc END .)
    *               reduce using rule 25 (exp -> ifc END .)
    DIV             reduce using rule 25 (exp -> ifc END .)
    POW             reduce using rule 25 (exp -> ifc END .)
    or              reduce using rule 25 (exp -> ifc END .)
    xor             reduce using rule 25 (exp -> ifc END .)
    and             reduce using rule 25 (exp -> ifc END .)
    imag            reduce using rule 25 (exp -> ifc END .)
    CMP             reduce using rule 25 (exp -> ifc END .)
    $end            reduce using rule 25 (exp -> ifc END .)
    )               reduce using rule 25 (exp -> ifc END .)
    ;               reduce using rule 25 (exp -> ifc END .)
    }               reduce using rule 25 (exp -> ifc END .)
    DO              reduce using rule 25 (exp -> ifc END .)
    THEN            reduce using rule 25 (exp -> ifc END .)
    ,               reduce using rule 25 (exp -> ifc END .)
    END             reduce using rule 25 (exp -> ifc END .)
    ELSE            reduce using rule 25 (exp -> ifc END .)
    ]               reduce using rule 25 (exp -> ifc END .)
    [               reduce using rule 25 (exp -> ifc END .)


state 43

    (26) exp -> FOR ID . IN it DO exp END

    IN              shift and go to state 80


state 44

    (27) exp -> ( exp . )
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    )               shift and go to state 81
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 45

    (44) exp -> not exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 44 (exp -> not exp .)
    -               reduce using rule 44 (exp -> not exp .)
    *               reduce using rule 44 (exp -> not exp .)
    DIV             reduce using rule 44 (exp -> not exp .)
    POW             reduce using rule 44 (exp -> not exp .)
    or              reduce using rule 44 (exp -> not exp .)
    xor             reduce using rule 44 (exp -> not exp .)
    and             reduce using rule 44 (exp -> not exp .)
    imag            reduce using rule 44 (exp -> not exp .)
    CMP             reduce using rule 44 (exp -> not exp .)
    $end            reduce using rule 44 (exp -> not exp .)
    )               reduce using rule 44 (exp -> not exp .)
    ;               reduce using rule 44 (exp -> not exp .)
    }               reduce using rule 44 (exp -> not exp .)
    DO              reduce using rule 44 (exp -> not exp .)
    THEN            reduce using rule 44 (exp -> not exp .)
    ,               reduce using rule 44 (exp -> not exp .)
    END             reduce using rule 44 (exp -> not exp .)
    ELSE            reduce using rule 44 (exp -> not exp .)
    ]               reduce using rule 44 (exp -> not exp .)
    [               reduce using rule 44 (exp -> not exp .)

  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! POW             [ shift and go to state 23 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! imag            [ shift and go to state 27 ]
  ! CMP             [ shift and go to state 28 ]


state 46

    (45) exp -> SYS exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 45 (exp -> SYS exp .)
    )               reduce using rule 45 (exp -> SYS exp .)
    ;               reduce using rule 45 (exp -> SYS exp .)
    }               reduce using rule 45 (exp -> SYS exp .)
    DO              reduce using rule 45 (exp -> SYS exp .)
    THEN            reduce using rule 45 (exp -> SYS exp .)
    ,               reduce using rule 45 (exp -> SYS exp .)
    END             reduce using rule 45 (exp -> SYS exp .)
    ELSE            reduce using rule 45 (exp -> SYS exp .)
    ]               reduce using rule 45 (exp -> SYS exp .)
    [               reduce using rule 45 (exp -> SYS exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 45 (exp -> SYS exp .) ]
  ! -               [ reduce using rule 45 (exp -> SYS exp .) ]
  ! *               [ reduce using rule 45 (exp -> SYS exp .) ]
  ! DIV             [ reduce using rule 45 (exp -> SYS exp .) ]
  ! POW             [ reduce using rule 45 (exp -> SYS exp .) ]
  ! or              [ reduce using rule 45 (exp -> SYS exp .) ]
  ! xor             [ reduce using rule 45 (exp -> SYS exp .) ]
  ! and             [ reduce using rule 45 (exp -> SYS exp .) ]
  ! imag            [ reduce using rule 45 (exp -> SYS exp .) ]
  ! CMP             [ reduce using rule 45 (exp -> SYS exp .) ]


state 47

    (49) exp -> { seq . }

    }               shift and go to state 82


state 48

    (46) seq -> exp . ; seq
    (47) seq -> exp . ;
    (48) seq -> exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ;               shift and go to state 83
    }               reduce using rule 48 (seq -> exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 49

    (53) exp -> WHILE exp . DO exp END
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    DO              shift and go to state 84
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 50

    (22) ifc -> IF exp . THEN exp
    (23) ifc -> IF exp . THEN exp ELSE exp
    (24) ifc -> IF exp . THEN exp ELSE ifc
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    THEN            shift and go to state 85
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 51

    (29) it -> [ exp . , exp ]
    (31) it -> [ exp . , exp [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ,               shift and go to state 86
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 52

    (30) it -> ] exp . , exp ]
    (32) it -> ] exp . , exp [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ,               shift and go to state 87
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 53

    (11) exp -> exp + exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 11 (exp -> exp + exp .)
    -               reduce using rule 11 (exp -> exp + exp .)
    or              reduce using rule 11 (exp -> exp + exp .)
    xor             reduce using rule 11 (exp -> exp + exp .)
    and             reduce using rule 11 (exp -> exp + exp .)
    CMP             reduce using rule 11 (exp -> exp + exp .)
    $end            reduce using rule 11 (exp -> exp + exp .)
    )               reduce using rule 11 (exp -> exp + exp .)
    ;               reduce using rule 11 (exp -> exp + exp .)
    }               reduce using rule 11 (exp -> exp + exp .)
    DO              reduce using rule 11 (exp -> exp + exp .)
    THEN            reduce using rule 11 (exp -> exp + exp .)
    ,               reduce using rule 11 (exp -> exp + exp .)
    END             reduce using rule 11 (exp -> exp + exp .)
    ELSE            reduce using rule 11 (exp -> exp + exp .)
    ]               reduce using rule 11 (exp -> exp + exp .)
    [               reduce using rule 11 (exp -> exp + exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! *               [ reduce using rule 11 (exp -> exp + exp .) ]
  ! DIV             [ reduce using rule 11 (exp -> exp + exp .) ]
  ! POW             [ reduce using rule 11 (exp -> exp + exp .) ]
  ! imag            [ reduce using rule 11 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 54

    (12) exp -> exp - exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 12 (exp -> exp - exp .)
    -               reduce using rule 12 (exp -> exp - exp .)
    or              reduce using rule 12 (exp -> exp - exp .)
    xor             reduce using rule 12 (exp -> exp - exp .)
    and             reduce using rule 12 (exp -> exp - exp .)
    CMP             reduce using rule 12 (exp -> exp - exp .)
    $end            reduce using rule 12 (exp -> exp - exp .)
    )               reduce using rule 12 (exp -> exp - exp .)
    ;               reduce using rule 12 (exp -> exp - exp .)
    }               reduce using rule 12 (exp -> exp - exp .)
    DO              reduce using rule 12 (exp -> exp - exp .)
    THEN            reduce using rule 12 (exp -> exp - exp .)
    ,               reduce using rule 12 (exp -> exp - exp .)
    END             reduce using rule 12 (exp -> exp - exp .)
    ELSE            reduce using rule 12 (exp -> exp - exp .)
    ]               reduce using rule 12 (exp -> exp - exp .)
    [               reduce using rule 12 (exp -> exp - exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! *               [ reduce using rule 12 (exp -> exp - exp .) ]
  ! DIV             [ reduce using rule 12 (exp -> exp - exp .) ]
  ! POW             [ reduce using rule 12 (exp -> exp - exp .) ]
  ! imag            [ reduce using rule 12 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 55

    (13) exp -> exp * exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 13 (exp -> exp * exp .)
    -               reduce using rule 13 (exp -> exp * exp .)
    *               reduce using rule 13 (exp -> exp * exp .)
    DIV             reduce using rule 13 (exp -> exp * exp .)
    or              reduce using rule 13 (exp -> exp * exp .)
    xor             reduce using rule 13 (exp -> exp * exp .)
    and             reduce using rule 13 (exp -> exp * exp .)
    CMP             reduce using rule 13 (exp -> exp * exp .)
    $end            reduce using rule 13 (exp -> exp * exp .)
    )               reduce using rule 13 (exp -> exp * exp .)
    ;               reduce using rule 13 (exp -> exp * exp .)
    }               reduce using rule 13 (exp -> exp * exp .)
    DO              reduce using rule 13 (exp -> exp * exp .)
    THEN            reduce using rule 13 (exp -> exp * exp .)
    ,               reduce using rule 13 (exp -> exp * exp .)
    END             reduce using rule 13 (exp -> exp * exp .)
    ELSE            reduce using rule 13 (exp -> exp * exp .)
    ]               reduce using rule 13 (exp -> exp * exp .)
    [               reduce using rule 13 (exp -> exp * exp .)
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! POW             [ reduce using rule 13 (exp -> exp * exp .) ]
  ! imag            [ reduce using rule 13 (exp -> exp * exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 56

    (14) exp -> exp DIV exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 14 (exp -> exp DIV exp .)
    -               reduce using rule 14 (exp -> exp DIV exp .)
    *               reduce using rule 14 (exp -> exp DIV exp .)
    DIV             reduce using rule 14 (exp -> exp DIV exp .)
    or              reduce using rule 14 (exp -> exp DIV exp .)
    xor             reduce using rule 14 (exp -> exp DIV exp .)
    and             reduce using rule 14 (exp -> exp DIV exp .)
    CMP             reduce using rule 14 (exp -> exp DIV exp .)
    $end            reduce using rule 14 (exp -> exp DIV exp .)
    )               reduce using rule 14 (exp -> exp DIV exp .)
    ;               reduce using rule 14 (exp -> exp DIV exp .)
    }               reduce using rule 14 (exp -> exp DIV exp .)
    DO              reduce using rule 14 (exp -> exp DIV exp .)
    THEN            reduce using rule 14 (exp -> exp DIV exp .)
    ,               reduce using rule 14 (exp -> exp DIV exp .)
    END             reduce using rule 14 (exp -> exp DIV exp .)
    ELSE            reduce using rule 14 (exp -> exp DIV exp .)
    ]               reduce using rule 14 (exp -> exp DIV exp .)
    [               reduce using rule 14 (exp -> exp DIV exp .)
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! POW             [ reduce using rule 14 (exp -> exp DIV exp .) ]
  ! imag            [ reduce using rule 14 (exp -> exp DIV exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 57

    (15) exp -> exp POW exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 15 (exp -> exp POW exp .)
    -               reduce using rule 15 (exp -> exp POW exp .)
    *               reduce using rule 15 (exp -> exp POW exp .)
    DIV             reduce using rule 15 (exp -> exp POW exp .)
    or              reduce using rule 15 (exp -> exp POW exp .)
    xor             reduce using rule 15 (exp -> exp POW exp .)
    and             reduce using rule 15 (exp -> exp POW exp .)
    CMP             reduce using rule 15 (exp -> exp POW exp .)
    $end            reduce using rule 15 (exp -> exp POW exp .)
    )               reduce using rule 15 (exp -> exp POW exp .)
    ;               reduce using rule 15 (exp -> exp POW exp .)
    }               reduce using rule 15 (exp -> exp POW exp .)
    DO              reduce using rule 15 (exp -> exp POW exp .)
    THEN            reduce using rule 15 (exp -> exp POW exp .)
    ,               reduce using rule 15 (exp -> exp POW exp .)
    END             reduce using rule 15 (exp -> exp POW exp .)
    ELSE            reduce using rule 15 (exp -> exp POW exp .)
    ]               reduce using rule 15 (exp -> exp POW exp .)
    [               reduce using rule 15 (exp -> exp POW exp .)
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! POW             [ reduce using rule 15 (exp -> exp POW exp .) ]
  ! imag            [ reduce using rule 15 (exp -> exp POW exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 58

    (16) exp -> exp or exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 16 (exp -> exp or exp .)
    $end            reduce using rule 16 (exp -> exp or exp .)
    )               reduce using rule 16 (exp -> exp or exp .)
    ;               reduce using rule 16 (exp -> exp or exp .)
    }               reduce using rule 16 (exp -> exp or exp .)
    DO              reduce using rule 16 (exp -> exp or exp .)
    THEN            reduce using rule 16 (exp -> exp or exp .)
    ,               reduce using rule 16 (exp -> exp or exp .)
    END             reduce using rule 16 (exp -> exp or exp .)
    ELSE            reduce using rule 16 (exp -> exp or exp .)
    ]               reduce using rule 16 (exp -> exp or exp .)
    [               reduce using rule 16 (exp -> exp or exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 16 (exp -> exp or exp .) ]
  ! -               [ reduce using rule 16 (exp -> exp or exp .) ]
  ! *               [ reduce using rule 16 (exp -> exp or exp .) ]
  ! DIV             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! POW             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! xor             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! and             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! imag            [ reduce using rule 16 (exp -> exp or exp .) ]
  ! CMP             [ reduce using rule 16 (exp -> exp or exp .) ]
  ! or              [ shift and go to state 24 ]


state 59

    (17) exp -> exp xor exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 17 (exp -> exp xor exp .)
    xor             reduce using rule 17 (exp -> exp xor exp .)
    $end            reduce using rule 17 (exp -> exp xor exp .)
    )               reduce using rule 17 (exp -> exp xor exp .)
    ;               reduce using rule 17 (exp -> exp xor exp .)
    }               reduce using rule 17 (exp -> exp xor exp .)
    DO              reduce using rule 17 (exp -> exp xor exp .)
    THEN            reduce using rule 17 (exp -> exp xor exp .)
    ,               reduce using rule 17 (exp -> exp xor exp .)
    END             reduce using rule 17 (exp -> exp xor exp .)
    ELSE            reduce using rule 17 (exp -> exp xor exp .)
    ]               reduce using rule 17 (exp -> exp xor exp .)
    [               reduce using rule 17 (exp -> exp xor exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! -               [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! *               [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! DIV             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! POW             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! and             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! imag            [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! CMP             [ reduce using rule 17 (exp -> exp xor exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]


state 60

    (18) exp -> exp and exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 18 (exp -> exp and exp .)
    xor             reduce using rule 18 (exp -> exp and exp .)
    and             reduce using rule 18 (exp -> exp and exp .)
    $end            reduce using rule 18 (exp -> exp and exp .)
    )               reduce using rule 18 (exp -> exp and exp .)
    ;               reduce using rule 18 (exp -> exp and exp .)
    }               reduce using rule 18 (exp -> exp and exp .)
    DO              reduce using rule 18 (exp -> exp and exp .)
    THEN            reduce using rule 18 (exp -> exp and exp .)
    ,               reduce using rule 18 (exp -> exp and exp .)
    END             reduce using rule 18 (exp -> exp and exp .)
    ELSE            reduce using rule 18 (exp -> exp and exp .)
    ]               reduce using rule 18 (exp -> exp and exp .)
    [               reduce using rule 18 (exp -> exp and exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 18 (exp -> exp and exp .) ]
  ! -               [ reduce using rule 18 (exp -> exp and exp .) ]
  ! *               [ reduce using rule 18 (exp -> exp and exp .) ]
  ! DIV             [ reduce using rule 18 (exp -> exp and exp .) ]
  ! POW             [ reduce using rule 18 (exp -> exp and exp .) ]
  ! imag            [ reduce using rule 18 (exp -> exp and exp .) ]
  ! CMP             [ reduce using rule 18 (exp -> exp and exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]


state 61

    (19) cmp -> exp CMP exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    CMP             reduce using rule 19 (cmp -> exp CMP exp .)
    or              reduce using rule 19 (cmp -> exp CMP exp .)
    xor             reduce using rule 19 (cmp -> exp CMP exp .)
    and             reduce using rule 19 (cmp -> exp CMP exp .)
    $end            reduce using rule 19 (cmp -> exp CMP exp .)
    )               reduce using rule 19 (cmp -> exp CMP exp .)
    ;               reduce using rule 19 (cmp -> exp CMP exp .)
    }               reduce using rule 19 (cmp -> exp CMP exp .)
    DO              reduce using rule 19 (cmp -> exp CMP exp .)
    THEN            reduce using rule 19 (cmp -> exp CMP exp .)
    ,               reduce using rule 19 (cmp -> exp CMP exp .)
    END             reduce using rule 19 (cmp -> exp CMP exp .)
    ELSE            reduce using rule 19 (cmp -> exp CMP exp .)
    ]               reduce using rule 19 (cmp -> exp CMP exp .)
    [               reduce using rule 19 (cmp -> exp CMP exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! +               [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! -               [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! *               [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! DIV             [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! POW             [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! imag            [ reduce using rule 19 (cmp -> exp CMP exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 62

    (1) exp -> ID + ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 88
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 63

    (34) exp -> ID + exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 34 (exp -> ID + exp .)
    -               reduce using rule 34 (exp -> ID + exp .)
    or              reduce using rule 34 (exp -> ID + exp .)
    xor             reduce using rule 34 (exp -> ID + exp .)
    and             reduce using rule 34 (exp -> ID + exp .)
    CMP             reduce using rule 34 (exp -> ID + exp .)
    $end            reduce using rule 34 (exp -> ID + exp .)
    )               reduce using rule 34 (exp -> ID + exp .)
    ;               reduce using rule 34 (exp -> ID + exp .)
    }               reduce using rule 34 (exp -> ID + exp .)
    DO              reduce using rule 34 (exp -> ID + exp .)
    THEN            reduce using rule 34 (exp -> ID + exp .)
    ,               reduce using rule 34 (exp -> ID + exp .)
    END             reduce using rule 34 (exp -> ID + exp .)
    ELSE            reduce using rule 34 (exp -> ID + exp .)
    ]               reduce using rule 34 (exp -> ID + exp .)
    [               reduce using rule 34 (exp -> ID + exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! *               [ reduce using rule 34 (exp -> ID + exp .) ]
  ! DIV             [ reduce using rule 34 (exp -> ID + exp .) ]
  ! POW             [ reduce using rule 34 (exp -> ID + exp .) ]
  ! imag            [ reduce using rule 34 (exp -> ID + exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 64

    (9) exp -> ID ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 9 (exp -> ID ASG exp .)
    )               reduce using rule 9 (exp -> ID ASG exp .)
    ;               reduce using rule 9 (exp -> ID ASG exp .)
    }               reduce using rule 9 (exp -> ID ASG exp .)
    DO              reduce using rule 9 (exp -> ID ASG exp .)
    THEN            reduce using rule 9 (exp -> ID ASG exp .)
    ,               reduce using rule 9 (exp -> ID ASG exp .)
    END             reduce using rule 9 (exp -> ID ASG exp .)
    ELSE            reduce using rule 9 (exp -> ID ASG exp .)
    ]               reduce using rule 9 (exp -> ID ASG exp .)
    [               reduce using rule 9 (exp -> ID ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! -               [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! *               [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! DIV             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! POW             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! or              [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! xor             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! and             [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! imag            [ reduce using rule 9 (exp -> ID ASG exp .) ]
  ! CMP             [ reduce using rule 9 (exp -> ID ASG exp .) ]


state 65

    (2) exp -> ID - ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 89
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 66

    (35) exp -> ID - exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 35 (exp -> ID - exp .)
    -               reduce using rule 35 (exp -> ID - exp .)
    or              reduce using rule 35 (exp -> ID - exp .)
    xor             reduce using rule 35 (exp -> ID - exp .)
    and             reduce using rule 35 (exp -> ID - exp .)
    CMP             reduce using rule 35 (exp -> ID - exp .)
    $end            reduce using rule 35 (exp -> ID - exp .)
    )               reduce using rule 35 (exp -> ID - exp .)
    ;               reduce using rule 35 (exp -> ID - exp .)
    }               reduce using rule 35 (exp -> ID - exp .)
    DO              reduce using rule 35 (exp -> ID - exp .)
    THEN            reduce using rule 35 (exp -> ID - exp .)
    ,               reduce using rule 35 (exp -> ID - exp .)
    END             reduce using rule 35 (exp -> ID - exp .)
    ELSE            reduce using rule 35 (exp -> ID - exp .)
    ]               reduce using rule 35 (exp -> ID - exp .)
    [               reduce using rule 35 (exp -> ID - exp .)
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! *               [ reduce using rule 35 (exp -> ID - exp .) ]
  ! DIV             [ reduce using rule 35 (exp -> ID - exp .) ]
  ! POW             [ reduce using rule 35 (exp -> ID - exp .) ]
  ! imag            [ reduce using rule 35 (exp -> ID - exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 67

    (3) exp -> ID * ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 90
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 68

    (36) exp -> ID * exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 36 (exp -> ID * exp .)
    -               reduce using rule 36 (exp -> ID * exp .)
    *               reduce using rule 36 (exp -> ID * exp .)
    DIV             reduce using rule 36 (exp -> ID * exp .)
    or              reduce using rule 36 (exp -> ID * exp .)
    xor             reduce using rule 36 (exp -> ID * exp .)
    and             reduce using rule 36 (exp -> ID * exp .)
    CMP             reduce using rule 36 (exp -> ID * exp .)
    $end            reduce using rule 36 (exp -> ID * exp .)
    )               reduce using rule 36 (exp -> ID * exp .)
    ;               reduce using rule 36 (exp -> ID * exp .)
    }               reduce using rule 36 (exp -> ID * exp .)
    DO              reduce using rule 36 (exp -> ID * exp .)
    THEN            reduce using rule 36 (exp -> ID * exp .)
    ,               reduce using rule 36 (exp -> ID * exp .)
    END             reduce using rule 36 (exp -> ID * exp .)
    ELSE            reduce using rule 36 (exp -> ID * exp .)
    ]               reduce using rule 36 (exp -> ID * exp .)
    [               reduce using rule 36 (exp -> ID * exp .)
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! POW             [ reduce using rule 36 (exp -> ID * exp .) ]
  ! imag            [ reduce using rule 36 (exp -> ID * exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 69

    (4) exp -> ID DIV ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 91
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 70

    (37) exp -> ID DIV exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 37 (exp -> ID DIV exp .)
    -               reduce using rule 37 (exp -> ID DIV exp .)
    *               reduce using rule 37 (exp -> ID DIV exp .)
    DIV             reduce using rule 37 (exp -> ID DIV exp .)
    or              reduce using rule 37 (exp -> ID DIV exp .)
    xor             reduce using rule 37 (exp -> ID DIV exp .)
    and             reduce using rule 37 (exp -> ID DIV exp .)
    CMP             reduce using rule 37 (exp -> ID DIV exp .)
    $end            reduce using rule 37 (exp -> ID DIV exp .)
    )               reduce using rule 37 (exp -> ID DIV exp .)
    ;               reduce using rule 37 (exp -> ID DIV exp .)
    }               reduce using rule 37 (exp -> ID DIV exp .)
    DO              reduce using rule 37 (exp -> ID DIV exp .)
    THEN            reduce using rule 37 (exp -> ID DIV exp .)
    ,               reduce using rule 37 (exp -> ID DIV exp .)
    END             reduce using rule 37 (exp -> ID DIV exp .)
    ELSE            reduce using rule 37 (exp -> ID DIV exp .)
    ]               reduce using rule 37 (exp -> ID DIV exp .)
    [               reduce using rule 37 (exp -> ID DIV exp .)
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! POW             [ reduce using rule 37 (exp -> ID DIV exp .) ]
  ! imag            [ reduce using rule 37 (exp -> ID DIV exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 71

    (5) exp -> ID POW ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 92
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 72

    (38) exp -> ID POW exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    +               reduce using rule 38 (exp -> ID POW exp .)
    -               reduce using rule 38 (exp -> ID POW exp .)
    *               reduce using rule 38 (exp -> ID POW exp .)
    DIV             reduce using rule 38 (exp -> ID POW exp .)
    or              reduce using rule 38 (exp -> ID POW exp .)
    xor             reduce using rule 38 (exp -> ID POW exp .)
    and             reduce using rule 38 (exp -> ID POW exp .)
    CMP             reduce using rule 38 (exp -> ID POW exp .)
    $end            reduce using rule 38 (exp -> ID POW exp .)
    )               reduce using rule 38 (exp -> ID POW exp .)
    ;               reduce using rule 38 (exp -> ID POW exp .)
    }               reduce using rule 38 (exp -> ID POW exp .)
    DO              reduce using rule 38 (exp -> ID POW exp .)
    THEN            reduce using rule 38 (exp -> ID POW exp .)
    ,               reduce using rule 38 (exp -> ID POW exp .)
    END             reduce using rule 38 (exp -> ID POW exp .)
    ELSE            reduce using rule 38 (exp -> ID POW exp .)
    ]               reduce using rule 38 (exp -> ID POW exp .)
    [               reduce using rule 38 (exp -> ID POW exp .)
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! POW             [ reduce using rule 38 (exp -> ID POW exp .) ]
  ! imag            [ reduce using rule 38 (exp -> ID POW exp .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! DIV             [ shift and go to state 22 ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 73

    (6) exp -> ID or ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 93
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 74

    (39) exp -> ID or exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 39 (exp -> ID or exp .)
    $end            reduce using rule 39 (exp -> ID or exp .)
    )               reduce using rule 39 (exp -> ID or exp .)
    ;               reduce using rule 39 (exp -> ID or exp .)
    }               reduce using rule 39 (exp -> ID or exp .)
    DO              reduce using rule 39 (exp -> ID or exp .)
    THEN            reduce using rule 39 (exp -> ID or exp .)
    ,               reduce using rule 39 (exp -> ID or exp .)
    END             reduce using rule 39 (exp -> ID or exp .)
    ELSE            reduce using rule 39 (exp -> ID or exp .)
    ]               reduce using rule 39 (exp -> ID or exp .)
    [               reduce using rule 39 (exp -> ID or exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 39 (exp -> ID or exp .) ]
  ! -               [ reduce using rule 39 (exp -> ID or exp .) ]
  ! *               [ reduce using rule 39 (exp -> ID or exp .) ]
  ! DIV             [ reduce using rule 39 (exp -> ID or exp .) ]
  ! POW             [ reduce using rule 39 (exp -> ID or exp .) ]
  ! xor             [ reduce using rule 39 (exp -> ID or exp .) ]
  ! and             [ reduce using rule 39 (exp -> ID or exp .) ]
  ! imag            [ reduce using rule 39 (exp -> ID or exp .) ]
  ! CMP             [ reduce using rule 39 (exp -> ID or exp .) ]
  ! or              [ shift and go to state 24 ]


state 75

    (7) exp -> ID xor ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 94
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 76

    (40) exp -> ID xor exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 40 (exp -> ID xor exp .)
    xor             reduce using rule 40 (exp -> ID xor exp .)
    $end            reduce using rule 40 (exp -> ID xor exp .)
    )               reduce using rule 40 (exp -> ID xor exp .)
    ;               reduce using rule 40 (exp -> ID xor exp .)
    }               reduce using rule 40 (exp -> ID xor exp .)
    DO              reduce using rule 40 (exp -> ID xor exp .)
    THEN            reduce using rule 40 (exp -> ID xor exp .)
    ,               reduce using rule 40 (exp -> ID xor exp .)
    END             reduce using rule 40 (exp -> ID xor exp .)
    ELSE            reduce using rule 40 (exp -> ID xor exp .)
    ]               reduce using rule 40 (exp -> ID xor exp .)
    [               reduce using rule 40 (exp -> ID xor exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! -               [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! *               [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! DIV             [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! POW             [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! and             [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! imag            [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! CMP             [ reduce using rule 40 (exp -> ID xor exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]


state 77

    (8) exp -> ID and ASG . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 95
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 78

    (41) exp -> ID and exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    or              reduce using rule 41 (exp -> ID and exp .)
    xor             reduce using rule 41 (exp -> ID and exp .)
    and             reduce using rule 41 (exp -> ID and exp .)
    $end            reduce using rule 41 (exp -> ID and exp .)
    )               reduce using rule 41 (exp -> ID and exp .)
    ;               reduce using rule 41 (exp -> ID and exp .)
    }               reduce using rule 41 (exp -> ID and exp .)
    DO              reduce using rule 41 (exp -> ID and exp .)
    THEN            reduce using rule 41 (exp -> ID and exp .)
    ,               reduce using rule 41 (exp -> ID and exp .)
    END             reduce using rule 41 (exp -> ID and exp .)
    ELSE            reduce using rule 41 (exp -> ID and exp .)
    ]               reduce using rule 41 (exp -> ID and exp .)
    [               reduce using rule 41 (exp -> ID and exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 41 (exp -> ID and exp .) ]
  ! -               [ reduce using rule 41 (exp -> ID and exp .) ]
  ! *               [ reduce using rule 41 (exp -> ID and exp .) ]
  ! DIV             [ reduce using rule 41 (exp -> ID and exp .) ]
  ! POW             [ reduce using rule 41 (exp -> ID and exp .) ]
  ! imag            [ reduce using rule 41 (exp -> ID and exp .) ]
  ! CMP             [ reduce using rule 41 (exp -> ID and exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]


state 79

    (20) cmp -> cmp CMP exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    CMP             reduce using rule 20 (cmp -> cmp CMP exp .)
    or              reduce using rule 20 (cmp -> cmp CMP exp .)
    xor             reduce using rule 20 (cmp -> cmp CMP exp .)
    and             reduce using rule 20 (cmp -> cmp CMP exp .)
    $end            reduce using rule 20 (cmp -> cmp CMP exp .)
    )               reduce using rule 20 (cmp -> cmp CMP exp .)
    ;               reduce using rule 20 (cmp -> cmp CMP exp .)
    }               reduce using rule 20 (cmp -> cmp CMP exp .)
    DO              reduce using rule 20 (cmp -> cmp CMP exp .)
    THEN            reduce using rule 20 (cmp -> cmp CMP exp .)
    ,               reduce using rule 20 (cmp -> cmp CMP exp .)
    END             reduce using rule 20 (cmp -> cmp CMP exp .)
    ELSE            reduce using rule 20 (cmp -> cmp CMP exp .)
    ]               reduce using rule 20 (cmp -> cmp CMP exp .)
    [               reduce using rule 20 (cmp -> cmp CMP exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    imag            shift and go to state 27

  ! +               [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! -               [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! *               [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! DIV             [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! POW             [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! imag            [ reduce using rule 20 (cmp -> cmp CMP exp .) ]
  ! or              [ shift and go to state 24 ]
  ! xor             [ shift and go to state 25 ]
  ! and             [ shift and go to state 26 ]
  ! CMP             [ shift and go to state 28 ]


state 80

    (26) exp -> FOR ID IN . it DO exp END
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    [               shift and go to state 17
    ]               shift and go to state 18

    it                             shift and go to state 96

state 81

    (27) exp -> ( exp ) .

    +               reduce using rule 27 (exp -> ( exp ) .)
    -               reduce using rule 27 (exp -> ( exp ) .)
    *               reduce using rule 27 (exp -> ( exp ) .)
    DIV             reduce using rule 27 (exp -> ( exp ) .)
    POW             reduce using rule 27 (exp -> ( exp ) .)
    or              reduce using rule 27 (exp -> ( exp ) .)
    xor             reduce using rule 27 (exp -> ( exp ) .)
    and             reduce using rule 27 (exp -> ( exp ) .)
    imag            reduce using rule 27 (exp -> ( exp ) .)
    CMP             reduce using rule 27 (exp -> ( exp ) .)
    $end            reduce using rule 27 (exp -> ( exp ) .)
    )               reduce using rule 27 (exp -> ( exp ) .)
    ;               reduce using rule 27 (exp -> ( exp ) .)
    }               reduce using rule 27 (exp -> ( exp ) .)
    DO              reduce using rule 27 (exp -> ( exp ) .)
    THEN            reduce using rule 27 (exp -> ( exp ) .)
    ,               reduce using rule 27 (exp -> ( exp ) .)
    END             reduce using rule 27 (exp -> ( exp ) .)
    ELSE            reduce using rule 27 (exp -> ( exp ) .)
    ]               reduce using rule 27 (exp -> ( exp ) .)
    [               reduce using rule 27 (exp -> ( exp ) .)


state 82

    (49) exp -> { seq } .

    +               reduce using rule 49 (exp -> { seq } .)
    -               reduce using rule 49 (exp -> { seq } .)
    *               reduce using rule 49 (exp -> { seq } .)
    DIV             reduce using rule 49 (exp -> { seq } .)
    POW             reduce using rule 49 (exp -> { seq } .)
    or              reduce using rule 49 (exp -> { seq } .)
    xor             reduce using rule 49 (exp -> { seq } .)
    and             reduce using rule 49 (exp -> { seq } .)
    imag            reduce using rule 49 (exp -> { seq } .)
    CMP             reduce using rule 49 (exp -> { seq } .)
    $end            reduce using rule 49 (exp -> { seq } .)
    )               reduce using rule 49 (exp -> { seq } .)
    ;               reduce using rule 49 (exp -> { seq } .)
    }               reduce using rule 49 (exp -> { seq } .)
    DO              reduce using rule 49 (exp -> { seq } .)
    THEN            reduce using rule 49 (exp -> { seq } .)
    ,               reduce using rule 49 (exp -> { seq } .)
    END             reduce using rule 49 (exp -> { seq } .)
    ELSE            reduce using rule 49 (exp -> { seq } .)
    ]               reduce using rule 49 (exp -> { seq } .)
    [               reduce using rule 49 (exp -> { seq } .)


state 83

    (46) seq -> exp ; . seq
    (47) seq -> exp ; .
    (46) seq -> . exp ; seq
    (47) seq -> . exp ;
    (48) seq -> . exp
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    }               reduce using rule 47 (seq -> exp ; .)
    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 48
    seq                            shift and go to state 97
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 84

    (53) exp -> WHILE exp DO . exp END
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 98
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 85

    (22) ifc -> IF exp THEN . exp
    (23) ifc -> IF exp THEN . exp ELSE exp
    (24) ifc -> IF exp THEN . exp ELSE ifc
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 99
    ifc                            shift and go to state 6
    cmp                            shift and go to state 5
    it                             shift and go to state 8

state 86

    (29) it -> [ exp , . exp ]
    (31) it -> [ exp , . exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 100
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 87

    (30) it -> ] exp , . exp ]
    (32) it -> ] exp , . exp [
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 101
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6
    it                             shift and go to state 8

state 88

    (1) exp -> ID + ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 1 (exp -> ID + ASG exp .)
    )               reduce using rule 1 (exp -> ID + ASG exp .)
    ;               reduce using rule 1 (exp -> ID + ASG exp .)
    }               reduce using rule 1 (exp -> ID + ASG exp .)
    DO              reduce using rule 1 (exp -> ID + ASG exp .)
    THEN            reduce using rule 1 (exp -> ID + ASG exp .)
    ,               reduce using rule 1 (exp -> ID + ASG exp .)
    END             reduce using rule 1 (exp -> ID + ASG exp .)
    ELSE            reduce using rule 1 (exp -> ID + ASG exp .)
    ]               reduce using rule 1 (exp -> ID + ASG exp .)
    [               reduce using rule 1 (exp -> ID + ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! -               [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! *               [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! DIV             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! POW             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! or              [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! xor             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! and             [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! imag            [ reduce using rule 1 (exp -> ID + ASG exp .) ]
  ! CMP             [ reduce using rule 1 (exp -> ID + ASG exp .) ]


state 89

    (2) exp -> ID - ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 2 (exp -> ID - ASG exp .)
    )               reduce using rule 2 (exp -> ID - ASG exp .)
    ;               reduce using rule 2 (exp -> ID - ASG exp .)
    }               reduce using rule 2 (exp -> ID - ASG exp .)
    DO              reduce using rule 2 (exp -> ID - ASG exp .)
    THEN            reduce using rule 2 (exp -> ID - ASG exp .)
    ,               reduce using rule 2 (exp -> ID - ASG exp .)
    END             reduce using rule 2 (exp -> ID - ASG exp .)
    ELSE            reduce using rule 2 (exp -> ID - ASG exp .)
    ]               reduce using rule 2 (exp -> ID - ASG exp .)
    [               reduce using rule 2 (exp -> ID - ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! -               [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! *               [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! DIV             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! POW             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! or              [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! xor             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! and             [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! imag            [ reduce using rule 2 (exp -> ID - ASG exp .) ]
  ! CMP             [ reduce using rule 2 (exp -> ID - ASG exp .) ]


state 90

    (3) exp -> ID * ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 3 (exp -> ID * ASG exp .)
    )               reduce using rule 3 (exp -> ID * ASG exp .)
    ;               reduce using rule 3 (exp -> ID * ASG exp .)
    }               reduce using rule 3 (exp -> ID * ASG exp .)
    DO              reduce using rule 3 (exp -> ID * ASG exp .)
    THEN            reduce using rule 3 (exp -> ID * ASG exp .)
    ,               reduce using rule 3 (exp -> ID * ASG exp .)
    END             reduce using rule 3 (exp -> ID * ASG exp .)
    ELSE            reduce using rule 3 (exp -> ID * ASG exp .)
    ]               reduce using rule 3 (exp -> ID * ASG exp .)
    [               reduce using rule 3 (exp -> ID * ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! -               [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! *               [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! DIV             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! POW             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! or              [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! xor             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! and             [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! imag            [ reduce using rule 3 (exp -> ID * ASG exp .) ]
  ! CMP             [ reduce using rule 3 (exp -> ID * ASG exp .) ]


state 91

    (4) exp -> ID DIV ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 4 (exp -> ID DIV ASG exp .)
    )               reduce using rule 4 (exp -> ID DIV ASG exp .)
    ;               reduce using rule 4 (exp -> ID DIV ASG exp .)
    }               reduce using rule 4 (exp -> ID DIV ASG exp .)
    DO              reduce using rule 4 (exp -> ID DIV ASG exp .)
    THEN            reduce using rule 4 (exp -> ID DIV ASG exp .)
    ,               reduce using rule 4 (exp -> ID DIV ASG exp .)
    END             reduce using rule 4 (exp -> ID DIV ASG exp .)
    ELSE            reduce using rule 4 (exp -> ID DIV ASG exp .)
    ]               reduce using rule 4 (exp -> ID DIV ASG exp .)
    [               reduce using rule 4 (exp -> ID DIV ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! -               [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! *               [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! DIV             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! POW             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! or              [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! xor             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! and             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! imag            [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]
  ! CMP             [ reduce using rule 4 (exp -> ID DIV ASG exp .) ]


state 92

    (5) exp -> ID POW ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 5 (exp -> ID POW ASG exp .)
    )               reduce using rule 5 (exp -> ID POW ASG exp .)
    ;               reduce using rule 5 (exp -> ID POW ASG exp .)
    }               reduce using rule 5 (exp -> ID POW ASG exp .)
    DO              reduce using rule 5 (exp -> ID POW ASG exp .)
    THEN            reduce using rule 5 (exp -> ID POW ASG exp .)
    ,               reduce using rule 5 (exp -> ID POW ASG exp .)
    END             reduce using rule 5 (exp -> ID POW ASG exp .)
    ELSE            reduce using rule 5 (exp -> ID POW ASG exp .)
    ]               reduce using rule 5 (exp -> ID POW ASG exp .)
    [               reduce using rule 5 (exp -> ID POW ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! -               [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! *               [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! DIV             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! POW             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! or              [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! xor             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! and             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! imag            [ reduce using rule 5 (exp -> ID POW ASG exp .) ]
  ! CMP             [ reduce using rule 5 (exp -> ID POW ASG exp .) ]


state 93

    (6) exp -> ID or ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 6 (exp -> ID or ASG exp .)
    )               reduce using rule 6 (exp -> ID or ASG exp .)
    ;               reduce using rule 6 (exp -> ID or ASG exp .)
    }               reduce using rule 6 (exp -> ID or ASG exp .)
    DO              reduce using rule 6 (exp -> ID or ASG exp .)
    THEN            reduce using rule 6 (exp -> ID or ASG exp .)
    ,               reduce using rule 6 (exp -> ID or ASG exp .)
    END             reduce using rule 6 (exp -> ID or ASG exp .)
    ELSE            reduce using rule 6 (exp -> ID or ASG exp .)
    ]               reduce using rule 6 (exp -> ID or ASG exp .)
    [               reduce using rule 6 (exp -> ID or ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! -               [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! *               [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! DIV             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! POW             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! or              [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! xor             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! and             [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! imag            [ reduce using rule 6 (exp -> ID or ASG exp .) ]
  ! CMP             [ reduce using rule 6 (exp -> ID or ASG exp .) ]


state 94

    (7) exp -> ID xor ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 7 (exp -> ID xor ASG exp .)
    )               reduce using rule 7 (exp -> ID xor ASG exp .)
    ;               reduce using rule 7 (exp -> ID xor ASG exp .)
    }               reduce using rule 7 (exp -> ID xor ASG exp .)
    DO              reduce using rule 7 (exp -> ID xor ASG exp .)
    THEN            reduce using rule 7 (exp -> ID xor ASG exp .)
    ,               reduce using rule 7 (exp -> ID xor ASG exp .)
    END             reduce using rule 7 (exp -> ID xor ASG exp .)
    ELSE            reduce using rule 7 (exp -> ID xor ASG exp .)
    ]               reduce using rule 7 (exp -> ID xor ASG exp .)
    [               reduce using rule 7 (exp -> ID xor ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! -               [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! *               [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! DIV             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! POW             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! or              [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! xor             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! and             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! imag            [ reduce using rule 7 (exp -> ID xor ASG exp .) ]
  ! CMP             [ reduce using rule 7 (exp -> ID xor ASG exp .) ]


state 95

    (8) exp -> ID and ASG exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    $end            reduce using rule 8 (exp -> ID and ASG exp .)
    )               reduce using rule 8 (exp -> ID and ASG exp .)
    ;               reduce using rule 8 (exp -> ID and ASG exp .)
    }               reduce using rule 8 (exp -> ID and ASG exp .)
    DO              reduce using rule 8 (exp -> ID and ASG exp .)
    THEN            reduce using rule 8 (exp -> ID and ASG exp .)
    ,               reduce using rule 8 (exp -> ID and ASG exp .)
    END             reduce using rule 8 (exp -> ID and ASG exp .)
    ELSE            reduce using rule 8 (exp -> ID and ASG exp .)
    ]               reduce using rule 8 (exp -> ID and ASG exp .)
    [               reduce using rule 8 (exp -> ID and ASG exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28

  ! +               [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! -               [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! *               [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! DIV             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! POW             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! or              [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! xor             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! and             [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! imag            [ reduce using rule 8 (exp -> ID and ASG exp .) ]
  ! CMP             [ reduce using rule 8 (exp -> ID and ASG exp .) ]


state 96

    (26) exp -> FOR ID IN it . DO exp END

    DO              shift and go to state 102


state 97

    (46) seq -> exp ; seq .

    }               reduce using rule 46 (seq -> exp ; seq .)


state 98

    (53) exp -> WHILE exp DO exp . END
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             shift and go to state 103
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 99

    (22) ifc -> IF exp THEN exp .
    (23) ifc -> IF exp THEN exp . ELSE exp
    (24) ifc -> IF exp THEN exp . ELSE ifc
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             reduce using rule 22 (ifc -> IF exp THEN exp .)
    ELSE            shift and go to state 104
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 100

    (29) it -> [ exp , exp . ]
    (31) it -> [ exp , exp . [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ]               shift and go to state 106
    [               shift and go to state 105
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 101

    (30) it -> ] exp , exp . ]
    (32) it -> ] exp , exp . [
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    ]               shift and go to state 107
    [               shift and go to state 108
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 102

    (26) exp -> FOR ID IN it DO . exp END
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    it                             shift and go to state 8
    exp                            shift and go to state 109
    cmp                            shift and go to state 5
    ifc                            shift and go to state 6

state 103

    (53) exp -> WHILE exp DO exp END .

    +               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    -               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    *               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    DIV             reduce using rule 53 (exp -> WHILE exp DO exp END .)
    POW             reduce using rule 53 (exp -> WHILE exp DO exp END .)
    or              reduce using rule 53 (exp -> WHILE exp DO exp END .)
    xor             reduce using rule 53 (exp -> WHILE exp DO exp END .)
    and             reduce using rule 53 (exp -> WHILE exp DO exp END .)
    imag            reduce using rule 53 (exp -> WHILE exp DO exp END .)
    CMP             reduce using rule 53 (exp -> WHILE exp DO exp END .)
    $end            reduce using rule 53 (exp -> WHILE exp DO exp END .)
    )               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    ;               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    }               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    DO              reduce using rule 53 (exp -> WHILE exp DO exp END .)
    THEN            reduce using rule 53 (exp -> WHILE exp DO exp END .)
    ,               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    END             reduce using rule 53 (exp -> WHILE exp DO exp END .)
    ELSE            reduce using rule 53 (exp -> WHILE exp DO exp END .)
    ]               reduce using rule 53 (exp -> WHILE exp DO exp END .)
    [               reduce using rule 53 (exp -> WHILE exp DO exp END .)


state 104

    (23) ifc -> IF exp THEN exp ELSE . exp
    (24) ifc -> IF exp THEN exp ELSE . ifc
    (1) exp -> . ID + ASG exp
    (2) exp -> . ID - ASG exp
    (3) exp -> . ID * ASG exp
    (4) exp -> . ID DIV ASG exp
    (5) exp -> . ID POW ASG exp
    (6) exp -> . ID or ASG exp
    (7) exp -> . ID xor ASG exp
    (8) exp -> . ID and ASG exp
    (9) exp -> . ID ASG exp
    (10) exp -> . ID USG
    (11) exp -> . exp + exp
    (12) exp -> . exp - exp
    (13) exp -> . exp * exp
    (14) exp -> . exp DIV exp
    (15) exp -> . exp POW exp
    (16) exp -> . exp or exp
    (17) exp -> . exp xor exp
    (18) exp -> . exp and exp
    (21) exp -> . cmp
    (25) exp -> . ifc END
    (26) exp -> . FOR ID IN it DO exp END
    (27) exp -> . ( exp )
    (28) exp -> . ID
    (33) exp -> . it
    (34) exp -> . ID + exp
    (35) exp -> . ID - exp
    (36) exp -> . ID * exp
    (37) exp -> . ID DIV exp
    (38) exp -> . ID POW exp
    (39) exp -> . ID or exp
    (40) exp -> . ID xor exp
    (41) exp -> . ID and exp
    (42) exp -> . + exp
    (43) exp -> . - exp
    (44) exp -> . not exp
    (45) exp -> . SYS exp
    (49) exp -> . { seq }
    (50) exp -> . STR
    (51) exp -> . exp imag
    (52) exp -> . NUM
    (53) exp -> . WHILE exp DO exp END
    (22) ifc -> . IF exp THEN exp
    (23) ifc -> . IF exp THEN exp ELSE exp
    (24) ifc -> . IF exp THEN exp ELSE ifc
    (19) cmp -> . exp CMP exp
    (20) cmp -> . cmp CMP exp
    (29) it -> . [ exp , exp ]
    (30) it -> . ] exp , exp ]
    (31) it -> . [ exp , exp [
    (32) it -> . ] exp , exp [

    ID              shift and go to state 2
    FOR             shift and go to state 7
    (               shift and go to state 9
    +               shift and go to state 3
    -               shift and go to state 4
    not             shift and go to state 10
    SYS             shift and go to state 11
    {               shift and go to state 12
    STR             shift and go to state 13
    NUM             shift and go to state 14
    WHILE           shift and go to state 15
    IF              shift and go to state 16
    [               shift and go to state 17
    ]               shift and go to state 18

    exp                            shift and go to state 110
    ifc                            shift and go to state 111
    cmp                            shift and go to state 5
    it                             shift and go to state 8

state 105

    (31) it -> [ exp , exp [ .

    +               reduce using rule 31 (it -> [ exp , exp [ .)
    -               reduce using rule 31 (it -> [ exp , exp [ .)
    *               reduce using rule 31 (it -> [ exp , exp [ .)
    DIV             reduce using rule 31 (it -> [ exp , exp [ .)
    POW             reduce using rule 31 (it -> [ exp , exp [ .)
    or              reduce using rule 31 (it -> [ exp , exp [ .)
    xor             reduce using rule 31 (it -> [ exp , exp [ .)
    and             reduce using rule 31 (it -> [ exp , exp [ .)
    imag            reduce using rule 31 (it -> [ exp , exp [ .)
    CMP             reduce using rule 31 (it -> [ exp , exp [ .)
    $end            reduce using rule 31 (it -> [ exp , exp [ .)
    )               reduce using rule 31 (it -> [ exp , exp [ .)
    ;               reduce using rule 31 (it -> [ exp , exp [ .)
    }               reduce using rule 31 (it -> [ exp , exp [ .)
    DO              reduce using rule 31 (it -> [ exp , exp [ .)
    THEN            reduce using rule 31 (it -> [ exp , exp [ .)
    ,               reduce using rule 31 (it -> [ exp , exp [ .)
    END             reduce using rule 31 (it -> [ exp , exp [ .)
    ELSE            reduce using rule 31 (it -> [ exp , exp [ .)
    ]               reduce using rule 31 (it -> [ exp , exp [ .)
    [               reduce using rule 31 (it -> [ exp , exp [ .)


state 106

    (29) it -> [ exp , exp ] .

    +               reduce using rule 29 (it -> [ exp , exp ] .)
    -               reduce using rule 29 (it -> [ exp , exp ] .)
    *               reduce using rule 29 (it -> [ exp , exp ] .)
    DIV             reduce using rule 29 (it -> [ exp , exp ] .)
    POW             reduce using rule 29 (it -> [ exp , exp ] .)
    or              reduce using rule 29 (it -> [ exp , exp ] .)
    xor             reduce using rule 29 (it -> [ exp , exp ] .)
    and             reduce using rule 29 (it -> [ exp , exp ] .)
    imag            reduce using rule 29 (it -> [ exp , exp ] .)
    CMP             reduce using rule 29 (it -> [ exp , exp ] .)
    $end            reduce using rule 29 (it -> [ exp , exp ] .)
    )               reduce using rule 29 (it -> [ exp , exp ] .)
    ;               reduce using rule 29 (it -> [ exp , exp ] .)
    }               reduce using rule 29 (it -> [ exp , exp ] .)
    DO              reduce using rule 29 (it -> [ exp , exp ] .)
    THEN            reduce using rule 29 (it -> [ exp , exp ] .)
    ,               reduce using rule 29 (it -> [ exp , exp ] .)
    END             reduce using rule 29 (it -> [ exp , exp ] .)
    ELSE            reduce using rule 29 (it -> [ exp , exp ] .)
    ]               reduce using rule 29 (it -> [ exp , exp ] .)
    [               reduce using rule 29 (it -> [ exp , exp ] .)


state 107

    (30) it -> ] exp , exp ] .

    +               reduce using rule 30 (it -> ] exp , exp ] .)
    -               reduce using rule 30 (it -> ] exp , exp ] .)
    *               reduce using rule 30 (it -> ] exp , exp ] .)
    DIV             reduce using rule 30 (it -> ] exp , exp ] .)
    POW             reduce using rule 30 (it -> ] exp , exp ] .)
    or              reduce using rule 30 (it -> ] exp , exp ] .)
    xor             reduce using rule 30 (it -> ] exp , exp ] .)
    and             reduce using rule 30 (it -> ] exp , exp ] .)
    imag            reduce using rule 30 (it -> ] exp , exp ] .)
    CMP             reduce using rule 30 (it -> ] exp , exp ] .)
    $end            reduce using rule 30 (it -> ] exp , exp ] .)
    )               reduce using rule 30 (it -> ] exp , exp ] .)
    ;               reduce using rule 30 (it -> ] exp , exp ] .)
    }               reduce using rule 30 (it -> ] exp , exp ] .)
    DO              reduce using rule 30 (it -> ] exp , exp ] .)
    THEN            reduce using rule 30 (it -> ] exp , exp ] .)
    ,               reduce using rule 30 (it -> ] exp , exp ] .)
    END             reduce using rule 30 (it -> ] exp , exp ] .)
    ELSE            reduce using rule 30 (it -> ] exp , exp ] .)
    ]               reduce using rule 30 (it -> ] exp , exp ] .)
    [               reduce using rule 30 (it -> ] exp , exp ] .)


state 108

    (32) it -> ] exp , exp [ .

    +               reduce using rule 32 (it -> ] exp , exp [ .)
    -               reduce using rule 32 (it -> ] exp , exp [ .)
    *               reduce using rule 32 (it -> ] exp , exp [ .)
    DIV             reduce using rule 32 (it -> ] exp , exp [ .)
    POW             reduce using rule 32 (it -> ] exp , exp [ .)
    or              reduce using rule 32 (it -> ] exp , exp [ .)
    xor             reduce using rule 32 (it -> ] exp , exp [ .)
    and             reduce using rule 32 (it -> ] exp , exp [ .)
    imag            reduce using rule 32 (it -> ] exp , exp [ .)
    CMP             reduce using rule 32 (it -> ] exp , exp [ .)
    $end            reduce using rule 32 (it -> ] exp , exp [ .)
    )               reduce using rule 32 (it -> ] exp , exp [ .)
    ;               reduce using rule 32 (it -> ] exp , exp [ .)
    }               reduce using rule 32 (it -> ] exp , exp [ .)
    DO              reduce using rule 32 (it -> ] exp , exp [ .)
    THEN            reduce using rule 32 (it -> ] exp , exp [ .)
    ,               reduce using rule 32 (it -> ] exp , exp [ .)
    END             reduce using rule 32 (it -> ] exp , exp [ .)
    ELSE            reduce using rule 32 (it -> ] exp , exp [ .)
    ]               reduce using rule 32 (it -> ] exp , exp [ .)
    [               reduce using rule 32 (it -> ] exp , exp [ .)


state 109

    (26) exp -> FOR ID IN it DO exp . END
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             shift and go to state 112
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 110

    (23) ifc -> IF exp THEN exp ELSE exp .
    (11) exp -> exp . + exp
    (12) exp -> exp . - exp
    (13) exp -> exp . * exp
    (14) exp -> exp . DIV exp
    (15) exp -> exp . POW exp
    (16) exp -> exp . or exp
    (17) exp -> exp . xor exp
    (18) exp -> exp . and exp
    (51) exp -> exp . imag
    (19) cmp -> exp . CMP exp

    END             reduce using rule 23 (ifc -> IF exp THEN exp ELSE exp .)
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    DIV             shift and go to state 22
    POW             shift and go to state 23
    or              shift and go to state 24
    xor             shift and go to state 25
    and             shift and go to state 26
    imag            shift and go to state 27
    CMP             shift and go to state 28


state 111

    (24) ifc -> IF exp THEN exp ELSE ifc .
    (25) exp -> ifc . END

    END             reduce using rule 24 (ifc -> IF exp THEN exp ELSE ifc .)

  ! END             [ shift and go to state 42 ]


state 112

    (26) exp -> FOR ID IN it DO exp END .

    +               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    -               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    *               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    DIV             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    POW             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    or              reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    xor             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    and             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    imag            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    CMP             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    $end            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    )               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ;               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    }               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    DO              reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    THEN            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ,               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    END             reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ELSE            reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    ]               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)
    [               reduce using rule 26 (exp -> FOR ID IN it DO exp END .)

