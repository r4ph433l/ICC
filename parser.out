Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> exp
Rule 1     arr -> exp , exp
Rule 2     arr -> arr , exp
Rule 3     exp -> arr
Rule 4     exp -> ( )
Rule 5     exp -> exp ,
Rule 6     exp -> exp [ exp ]
Rule 7     exp -> ID + ASG exp
Rule 8     exp -> ID - ASG exp
Rule 9     exp -> ID USG
Rule 10    exp -> ID * ASG exp
Rule 11    exp -> ID DIV ASG exp
Rule 12    exp -> ID MOD ASG exp
Rule 13    exp -> ID POW ASG exp
Rule 14    exp -> ID OR ASG exp
Rule 15    exp -> ID XOR ASG exp
Rule 16    exp -> ID AND ASG exp
Rule 17    exp -> ID ASG exp
Rule 18    exp -> exp + exp
Rule 19    exp -> exp - exp
Rule 20    exp -> exp * exp
Rule 21    exp -> exp DIV exp
Rule 22    exp -> exp MOD exp
Rule 23    exp -> exp POW exp
Rule 24    exp -> exp OR exp
Rule 25    exp -> exp XOR exp
Rule 26    exp -> exp AND exp
Rule 27    cmp -> exp CMP exp
Rule 28    cmp -> cmp CMP exp
Rule 29    exp -> cmp
Rule 30    ifc -> IF exp : exp
Rule 31    ifc -> IF exp : exp ELSE exp
Rule 32    ifc -> IF exp : exp ELSE ifc
Rule 33    exp -> ifc END
Rule 34    exp -> FOR ID IN exp : exp END
Rule 35    exp -> FOR NUM ID IN it : exp END
Rule 36    exp -> exp TO exp
Rule 37    exp -> ID ( exp )
Rule 38    exp -> ( exp )
Rule 39    exp -> ID
Rule 40    it -> [ exp , exp ]
Rule 41    it -> ] exp , exp ]
Rule 42    it -> [ exp , exp [
Rule 43    it -> ] exp , exp [
Rule 44    exp -> it
Rule 45    exp -> exp IN it
Rule 46    exp -> ID + exp
Rule 47    exp -> ID - exp
Rule 48    exp -> - exp
Rule 49    exp -> ID * exp
Rule 50    exp -> ID DIV exp
Rule 51    exp -> ID MOD exp
Rule 52    exp -> ID POW exp
Rule 53    exp -> ID OR exp
Rule 54    exp -> ID XOR exp
Rule 55    exp -> ID AND exp
Rule 56    exp -> + exp
Rule 57    exp -> NOT exp
Rule 58    exp -> ECHO exp
Rule 59    exp -> LOAD exp
Rule 60    exp -> EVAL exp
Rule 61    seq -> exp ; seq
Rule 62    seq -> exp ;
Rule 63    seq -> exp
Rule 64    exp -> { seq }
Rule 65    exp -> NUM
Rule 66    exp -> STR
Rule 67    exp -> WHILE exp : exp END

Terminals, with rules where they appear

(                    : 4 37 38
)                    : 4 37 38
*                    : 10 20 49
+                    : 7 18 46 56
,                    : 1 2 5 40 41 42 43
-                    : 8 19 47 48
:                    : 30 31 32 34 35 67
;                    : 61 62
AND                  : 16 26 55
ASG                  : 7 8 10 11 12 13 14 15 16 17
CMP                  : 27 28
DIV                  : 11 21 50
ECHO                 : 58
ELSE                 : 31 32
END                  : 33 34 35 67
EVAL                 : 60
FOR                  : 34 35
ID                   : 7 8 9 10 11 12 13 14 15 16 17 34 35 37 39 46 47 49 50 51 52 53 54 55
IF                   : 30 31 32
IN                   : 34 35 45
LOAD                 : 59
MOD                  : 12 22 51
NOT                  : 57
NUM                  : 35 65
OR                   : 14 24 53
POW                  : 13 23 52
STR                  : 66
TO                   : 36
USG                  : 9
WHILE                : 67
XOR                  : 15 25 54
[                    : 6 40 42 42 43
]                    : 6 40 41 41 43
error                : 
{                    : 64
}                    : 64

Nonterminals, with rules where they appear

arr                  : 2 3
cmp                  : 28 29
exp                  : 1 1 2 5 6 6 7 8 10 11 12 13 14 15 16 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 30 30 31 31 31 32 32 34 34 35 36 36 37 38 40 40 41 41 42 42 43 43 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 67 67 0
ifc                  : 32 33
it                   : 35 44 45
seq                  : 61 64

Parsing method: LALR

state 0

    (0) S' -> . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 1
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 1

    (0) S' -> exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 2

    (3) exp -> arr .
    (2) arr -> arr . , exp

    [               reduce using rule 3 (exp -> arr .)
    +               reduce using rule 3 (exp -> arr .)
    -               reduce using rule 3 (exp -> arr .)
    *               reduce using rule 3 (exp -> arr .)
    DIV             reduce using rule 3 (exp -> arr .)
    MOD             reduce using rule 3 (exp -> arr .)
    POW             reduce using rule 3 (exp -> arr .)
    OR              reduce using rule 3 (exp -> arr .)
    XOR             reduce using rule 3 (exp -> arr .)
    AND             reduce using rule 3 (exp -> arr .)
    TO              reduce using rule 3 (exp -> arr .)
    IN              reduce using rule 3 (exp -> arr .)
    CMP             reduce using rule 3 (exp -> arr .)
    $end            reduce using rule 3 (exp -> arr .)
    )               reduce using rule 3 (exp -> arr .)
    ;               reduce using rule 3 (exp -> arr .)
    }               reduce using rule 3 (exp -> arr .)
    :               reduce using rule 3 (exp -> arr .)
    ]               reduce using rule 3 (exp -> arr .)
    END             reduce using rule 3 (exp -> arr .)
    ELSE            reduce using rule 3 (exp -> arr .)
    ,               shift and go to state 36

  ! ,               [ reduce using rule 3 (exp -> arr .) ]


state 3

    (4) exp -> ( . )
    (38) exp -> ( . exp )
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    )               shift and go to state 37
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 38
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 4

    (40) it -> [ . exp , exp ]
    (42) it -> [ . exp , exp [
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 39
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 5

    (41) it -> ] . exp , exp ]
    (43) it -> ] . exp , exp [
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 40
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 6

    (7) exp -> ID . + ASG exp
    (8) exp -> ID . - ASG exp
    (9) exp -> ID . USG
    (10) exp -> ID . * ASG exp
    (11) exp -> ID . DIV ASG exp
    (12) exp -> ID . MOD ASG exp
    (13) exp -> ID . POW ASG exp
    (14) exp -> ID . OR ASG exp
    (15) exp -> ID . XOR ASG exp
    (16) exp -> ID . AND ASG exp
    (17) exp -> ID . ASG exp
    (37) exp -> ID . ( exp )
    (39) exp -> ID .
    (46) exp -> ID . + exp
    (47) exp -> ID . - exp
    (49) exp -> ID . * exp
    (50) exp -> ID . DIV exp
    (51) exp -> ID . MOD exp
    (52) exp -> ID . POW exp
    (53) exp -> ID . OR exp
    (54) exp -> ID . XOR exp
    (55) exp -> ID . AND exp

    +               shift and go to state 41
    -               shift and go to state 43
    USG             shift and go to state 44
    *               shift and go to state 45
    DIV             shift and go to state 46
    MOD             shift and go to state 47
    POW             shift and go to state 48
    OR              shift and go to state 49
    XOR             shift and go to state 50
    AND             shift and go to state 51
    ASG             shift and go to state 42
    (               shift and go to state 52
    ,               reduce using rule 39 (exp -> ID .)
    [               reduce using rule 39 (exp -> ID .)
    TO              reduce using rule 39 (exp -> ID .)
    IN              reduce using rule 39 (exp -> ID .)
    CMP             reduce using rule 39 (exp -> ID .)
    $end            reduce using rule 39 (exp -> ID .)
    )               reduce using rule 39 (exp -> ID .)
    ;               reduce using rule 39 (exp -> ID .)
    }               reduce using rule 39 (exp -> ID .)
    :               reduce using rule 39 (exp -> ID .)
    ]               reduce using rule 39 (exp -> ID .)
    END             reduce using rule 39 (exp -> ID .)
    ELSE            reduce using rule 39 (exp -> ID .)

  ! +               [ reduce using rule 39 (exp -> ID .) ]
  ! -               [ reduce using rule 39 (exp -> ID .) ]
  ! *               [ reduce using rule 39 (exp -> ID .) ]
  ! DIV             [ reduce using rule 39 (exp -> ID .) ]
  ! MOD             [ reduce using rule 39 (exp -> ID .) ]
  ! POW             [ reduce using rule 39 (exp -> ID .) ]
  ! OR              [ reduce using rule 39 (exp -> ID .) ]
  ! XOR             [ reduce using rule 39 (exp -> ID .) ]
  ! AND             [ reduce using rule 39 (exp -> ID .) ]


state 7

    (56) exp -> + . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 53
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 8

    (48) exp -> - . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 54
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 9

    (29) exp -> cmp .
    (28) cmp -> cmp . CMP exp

    ,               reduce using rule 29 (exp -> cmp .)
    [               reduce using rule 29 (exp -> cmp .)
    +               reduce using rule 29 (exp -> cmp .)
    -               reduce using rule 29 (exp -> cmp .)
    *               reduce using rule 29 (exp -> cmp .)
    DIV             reduce using rule 29 (exp -> cmp .)
    MOD             reduce using rule 29 (exp -> cmp .)
    POW             reduce using rule 29 (exp -> cmp .)
    OR              reduce using rule 29 (exp -> cmp .)
    XOR             reduce using rule 29 (exp -> cmp .)
    AND             reduce using rule 29 (exp -> cmp .)
    TO              reduce using rule 29 (exp -> cmp .)
    IN              reduce using rule 29 (exp -> cmp .)
    $end            reduce using rule 29 (exp -> cmp .)
    )               reduce using rule 29 (exp -> cmp .)
    ;               reduce using rule 29 (exp -> cmp .)
    }               reduce using rule 29 (exp -> cmp .)
    :               reduce using rule 29 (exp -> cmp .)
    ]               reduce using rule 29 (exp -> cmp .)
    END             reduce using rule 29 (exp -> cmp .)
    ELSE            reduce using rule 29 (exp -> cmp .)
    CMP             shift and go to state 55

  ! CMP             [ reduce using rule 29 (exp -> cmp .) ]


state 10

    (33) exp -> ifc . END

    END             shift and go to state 56


state 11

    (34) exp -> FOR . ID IN exp : exp END
    (35) exp -> FOR . NUM ID IN it : exp END

    ID              shift and go to state 57
    NUM             shift and go to state 58


state 12

    (65) exp -> NUM .

    ,               reduce using rule 65 (exp -> NUM .)
    [               reduce using rule 65 (exp -> NUM .)
    +               reduce using rule 65 (exp -> NUM .)
    -               reduce using rule 65 (exp -> NUM .)
    *               reduce using rule 65 (exp -> NUM .)
    DIV             reduce using rule 65 (exp -> NUM .)
    MOD             reduce using rule 65 (exp -> NUM .)
    POW             reduce using rule 65 (exp -> NUM .)
    OR              reduce using rule 65 (exp -> NUM .)
    XOR             reduce using rule 65 (exp -> NUM .)
    AND             reduce using rule 65 (exp -> NUM .)
    TO              reduce using rule 65 (exp -> NUM .)
    IN              reduce using rule 65 (exp -> NUM .)
    CMP             reduce using rule 65 (exp -> NUM .)
    $end            reduce using rule 65 (exp -> NUM .)
    )               reduce using rule 65 (exp -> NUM .)
    ;               reduce using rule 65 (exp -> NUM .)
    }               reduce using rule 65 (exp -> NUM .)
    :               reduce using rule 65 (exp -> NUM .)
    ]               reduce using rule 65 (exp -> NUM .)
    END             reduce using rule 65 (exp -> NUM .)
    ELSE            reduce using rule 65 (exp -> NUM .)


state 13

    (44) exp -> it .

    ,               reduce using rule 44 (exp -> it .)
    [               reduce using rule 44 (exp -> it .)
    +               reduce using rule 44 (exp -> it .)
    -               reduce using rule 44 (exp -> it .)
    *               reduce using rule 44 (exp -> it .)
    DIV             reduce using rule 44 (exp -> it .)
    MOD             reduce using rule 44 (exp -> it .)
    POW             reduce using rule 44 (exp -> it .)
    OR              reduce using rule 44 (exp -> it .)
    XOR             reduce using rule 44 (exp -> it .)
    AND             reduce using rule 44 (exp -> it .)
    TO              reduce using rule 44 (exp -> it .)
    IN              reduce using rule 44 (exp -> it .)
    CMP             reduce using rule 44 (exp -> it .)
    $end            reduce using rule 44 (exp -> it .)
    )               reduce using rule 44 (exp -> it .)
    ;               reduce using rule 44 (exp -> it .)
    }               reduce using rule 44 (exp -> it .)
    :               reduce using rule 44 (exp -> it .)
    ]               reduce using rule 44 (exp -> it .)
    END             reduce using rule 44 (exp -> it .)
    ELSE            reduce using rule 44 (exp -> it .)


state 14

    (57) exp -> NOT . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 59
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 15

    (58) exp -> ECHO . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 60
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 16

    (59) exp -> LOAD . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 61
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 17

    (60) exp -> EVAL . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 62
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 18

    (64) exp -> { . seq }
    (61) seq -> . exp ; seq
    (62) seq -> . exp ;
    (63) seq -> . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    seq                            shift and go to state 63
    exp                            shift and go to state 64
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 19

    (66) exp -> STR .

    ,               reduce using rule 66 (exp -> STR .)
    [               reduce using rule 66 (exp -> STR .)
    +               reduce using rule 66 (exp -> STR .)
    -               reduce using rule 66 (exp -> STR .)
    *               reduce using rule 66 (exp -> STR .)
    DIV             reduce using rule 66 (exp -> STR .)
    MOD             reduce using rule 66 (exp -> STR .)
    POW             reduce using rule 66 (exp -> STR .)
    OR              reduce using rule 66 (exp -> STR .)
    XOR             reduce using rule 66 (exp -> STR .)
    AND             reduce using rule 66 (exp -> STR .)
    TO              reduce using rule 66 (exp -> STR .)
    IN              reduce using rule 66 (exp -> STR .)
    CMP             reduce using rule 66 (exp -> STR .)
    $end            reduce using rule 66 (exp -> STR .)
    )               reduce using rule 66 (exp -> STR .)
    ;               reduce using rule 66 (exp -> STR .)
    }               reduce using rule 66 (exp -> STR .)
    :               reduce using rule 66 (exp -> STR .)
    ]               reduce using rule 66 (exp -> STR .)
    END             reduce using rule 66 (exp -> STR .)
    ELSE            reduce using rule 66 (exp -> STR .)


state 20

    (67) exp -> WHILE . exp : exp END
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 65
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 21

    (30) ifc -> IF . exp : exp
    (31) ifc -> IF . exp : exp ELSE exp
    (32) ifc -> IF . exp : exp ELSE ifc
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 66
    ifc                            shift and go to state 10
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    it                             shift and go to state 13

state 22

    (5) exp -> exp , .
    (1) arr -> exp , . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ,               reduce using rule 5 (exp -> exp , .)
    *               reduce using rule 5 (exp -> exp , .)
    DIV             reduce using rule 5 (exp -> exp , .)
    MOD             reduce using rule 5 (exp -> exp , .)
    POW             reduce using rule 5 (exp -> exp , .)
    OR              reduce using rule 5 (exp -> exp , .)
    XOR             reduce using rule 5 (exp -> exp , .)
    AND             reduce using rule 5 (exp -> exp , .)
    TO              reduce using rule 5 (exp -> exp , .)
    IN              reduce using rule 5 (exp -> exp , .)
    CMP             reduce using rule 5 (exp -> exp , .)
    $end            reduce using rule 5 (exp -> exp , .)
    )               reduce using rule 5 (exp -> exp , .)
    ;               reduce using rule 5 (exp -> exp , .)
    }               reduce using rule 5 (exp -> exp , .)
    :               reduce using rule 5 (exp -> exp , .)
    ]               reduce using rule 5 (exp -> exp , .)
    END             reduce using rule 5 (exp -> exp , .)
    ELSE            reduce using rule 5 (exp -> exp , .)
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4

  ! [               [ reduce using rule 5 (exp -> exp , .) ]
  ! +               [ reduce using rule 5 (exp -> exp , .) ]
  ! -               [ reduce using rule 5 (exp -> exp , .) ]
  ! ]               [ shift and go to state 5 ]

    exp                            shift and go to state 67
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 23

    (6) exp -> exp [ . exp ]
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 68
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 24

    (18) exp -> exp + . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 69
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 25

    (19) exp -> exp - . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 70
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 26

    (20) exp -> exp * . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 71
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 27

    (21) exp -> exp DIV . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 72
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 28

    (22) exp -> exp MOD . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 73
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 29

    (23) exp -> exp POW . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 74
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 30

    (24) exp -> exp OR . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 75
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 31

    (25) exp -> exp XOR . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 76
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 32

    (26) exp -> exp AND . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 77
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 33

    (36) exp -> exp TO . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 78
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 34

    (45) exp -> exp IN . it
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    [               shift and go to state 4
    ]               shift and go to state 5

    it                             shift and go to state 79

state 35

    (27) cmp -> exp CMP . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 80
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 36

    (2) arr -> arr , . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    arr                            shift and go to state 2
    exp                            shift and go to state 81
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 37

    (4) exp -> ( ) .

    ,               reduce using rule 4 (exp -> ( ) .)
    [               reduce using rule 4 (exp -> ( ) .)
    +               reduce using rule 4 (exp -> ( ) .)
    -               reduce using rule 4 (exp -> ( ) .)
    *               reduce using rule 4 (exp -> ( ) .)
    DIV             reduce using rule 4 (exp -> ( ) .)
    MOD             reduce using rule 4 (exp -> ( ) .)
    POW             reduce using rule 4 (exp -> ( ) .)
    OR              reduce using rule 4 (exp -> ( ) .)
    XOR             reduce using rule 4 (exp -> ( ) .)
    AND             reduce using rule 4 (exp -> ( ) .)
    TO              reduce using rule 4 (exp -> ( ) .)
    IN              reduce using rule 4 (exp -> ( ) .)
    CMP             reduce using rule 4 (exp -> ( ) .)
    $end            reduce using rule 4 (exp -> ( ) .)
    )               reduce using rule 4 (exp -> ( ) .)
    ;               reduce using rule 4 (exp -> ( ) .)
    }               reduce using rule 4 (exp -> ( ) .)
    :               reduce using rule 4 (exp -> ( ) .)
    ]               reduce using rule 4 (exp -> ( ) .)
    END             reduce using rule 4 (exp -> ( ) .)
    ELSE            reduce using rule 4 (exp -> ( ) .)


state 38

    (38) exp -> ( exp . )
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    )               shift and go to state 82
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 39

    (40) it -> [ exp . , exp ]
    (42) it -> [ exp . , exp [
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               shift and go to state 83
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 40

    (41) it -> ] exp . , exp ]
    (43) it -> ] exp . , exp [
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               shift and go to state 84
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 41

    (7) exp -> ID + . ASG exp
    (46) exp -> ID + . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 85
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 86
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 42

    (17) exp -> ID ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 87
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 43

    (8) exp -> ID - . ASG exp
    (47) exp -> ID - . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 88
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 89
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 44

    (9) exp -> ID USG .

    ,               reduce using rule 9 (exp -> ID USG .)
    [               reduce using rule 9 (exp -> ID USG .)
    +               reduce using rule 9 (exp -> ID USG .)
    -               reduce using rule 9 (exp -> ID USG .)
    *               reduce using rule 9 (exp -> ID USG .)
    DIV             reduce using rule 9 (exp -> ID USG .)
    MOD             reduce using rule 9 (exp -> ID USG .)
    POW             reduce using rule 9 (exp -> ID USG .)
    OR              reduce using rule 9 (exp -> ID USG .)
    XOR             reduce using rule 9 (exp -> ID USG .)
    AND             reduce using rule 9 (exp -> ID USG .)
    TO              reduce using rule 9 (exp -> ID USG .)
    IN              reduce using rule 9 (exp -> ID USG .)
    CMP             reduce using rule 9 (exp -> ID USG .)
    $end            reduce using rule 9 (exp -> ID USG .)
    )               reduce using rule 9 (exp -> ID USG .)
    ;               reduce using rule 9 (exp -> ID USG .)
    }               reduce using rule 9 (exp -> ID USG .)
    :               reduce using rule 9 (exp -> ID USG .)
    ]               reduce using rule 9 (exp -> ID USG .)
    END             reduce using rule 9 (exp -> ID USG .)
    ELSE            reduce using rule 9 (exp -> ID USG .)


state 45

    (10) exp -> ID * . ASG exp
    (49) exp -> ID * . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 90
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 91
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 46

    (11) exp -> ID DIV . ASG exp
    (50) exp -> ID DIV . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 92
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 93
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 47

    (12) exp -> ID MOD . ASG exp
    (51) exp -> ID MOD . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 94
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 95
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 48

    (13) exp -> ID POW . ASG exp
    (52) exp -> ID POW . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 96
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 97
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 49

    (14) exp -> ID OR . ASG exp
    (53) exp -> ID OR . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 98
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 99
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 50

    (15) exp -> ID XOR . ASG exp
    (54) exp -> ID XOR . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 100
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 101
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 51

    (16) exp -> ID AND . ASG exp
    (55) exp -> ID AND . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ASG             shift and go to state 102
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 103
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 52

    (37) exp -> ID ( . exp )
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 104
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 53

    (56) exp -> + exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 56 (exp -> + exp .)
    +               reduce using rule 56 (exp -> + exp .)
    -               reduce using rule 56 (exp -> + exp .)
    OR              reduce using rule 56 (exp -> + exp .)
    XOR             reduce using rule 56 (exp -> + exp .)
    AND             reduce using rule 56 (exp -> + exp .)
    TO              reduce using rule 56 (exp -> + exp .)
    IN              reduce using rule 56 (exp -> + exp .)
    CMP             reduce using rule 56 (exp -> + exp .)
    $end            reduce using rule 56 (exp -> + exp .)
    )               reduce using rule 56 (exp -> + exp .)
    ;               reduce using rule 56 (exp -> + exp .)
    }               reduce using rule 56 (exp -> + exp .)
    :               reduce using rule 56 (exp -> + exp .)
    ]               reduce using rule 56 (exp -> + exp .)
    END             reduce using rule 56 (exp -> + exp .)
    ELSE            reduce using rule 56 (exp -> + exp .)
    [               shift and go to state 23
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 56 (exp -> + exp .) ]
  ! *               [ reduce using rule 56 (exp -> + exp .) ]
  ! DIV             [ reduce using rule 56 (exp -> + exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> + exp .) ]
  ! POW             [ reduce using rule 56 (exp -> + exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 54

    (48) exp -> - exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 48 (exp -> - exp .)
    +               reduce using rule 48 (exp -> - exp .)
    -               reduce using rule 48 (exp -> - exp .)
    OR              reduce using rule 48 (exp -> - exp .)
    XOR             reduce using rule 48 (exp -> - exp .)
    AND             reduce using rule 48 (exp -> - exp .)
    TO              reduce using rule 48 (exp -> - exp .)
    IN              reduce using rule 48 (exp -> - exp .)
    CMP             reduce using rule 48 (exp -> - exp .)
    $end            reduce using rule 48 (exp -> - exp .)
    )               reduce using rule 48 (exp -> - exp .)
    ;               reduce using rule 48 (exp -> - exp .)
    }               reduce using rule 48 (exp -> - exp .)
    :               reduce using rule 48 (exp -> - exp .)
    ]               reduce using rule 48 (exp -> - exp .)
    END             reduce using rule 48 (exp -> - exp .)
    ELSE            reduce using rule 48 (exp -> - exp .)
    [               shift and go to state 23
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 48 (exp -> - exp .) ]
  ! *               [ reduce using rule 48 (exp -> - exp .) ]
  ! DIV             [ reduce using rule 48 (exp -> - exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> - exp .) ]
  ! POW             [ reduce using rule 48 (exp -> - exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 55

    (28) cmp -> cmp CMP . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    cmp                            shift and go to state 9
    exp                            shift and go to state 105
    arr                            shift and go to state 2
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 56

    (33) exp -> ifc END .

    ,               reduce using rule 33 (exp -> ifc END .)
    [               reduce using rule 33 (exp -> ifc END .)
    +               reduce using rule 33 (exp -> ifc END .)
    -               reduce using rule 33 (exp -> ifc END .)
    *               reduce using rule 33 (exp -> ifc END .)
    DIV             reduce using rule 33 (exp -> ifc END .)
    MOD             reduce using rule 33 (exp -> ifc END .)
    POW             reduce using rule 33 (exp -> ifc END .)
    OR              reduce using rule 33 (exp -> ifc END .)
    XOR             reduce using rule 33 (exp -> ifc END .)
    AND             reduce using rule 33 (exp -> ifc END .)
    TO              reduce using rule 33 (exp -> ifc END .)
    IN              reduce using rule 33 (exp -> ifc END .)
    CMP             reduce using rule 33 (exp -> ifc END .)
    $end            reduce using rule 33 (exp -> ifc END .)
    )               reduce using rule 33 (exp -> ifc END .)
    ;               reduce using rule 33 (exp -> ifc END .)
    }               reduce using rule 33 (exp -> ifc END .)
    :               reduce using rule 33 (exp -> ifc END .)
    ]               reduce using rule 33 (exp -> ifc END .)
    END             reduce using rule 33 (exp -> ifc END .)
    ELSE            reduce using rule 33 (exp -> ifc END .)


state 57

    (34) exp -> FOR ID . IN exp : exp END

    IN              shift and go to state 106


state 58

    (35) exp -> FOR NUM . ID IN it : exp END

    ID              shift and go to state 107


state 59

    (57) exp -> NOT exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 57 (exp -> NOT exp .)
    +               reduce using rule 57 (exp -> NOT exp .)
    -               reduce using rule 57 (exp -> NOT exp .)
    *               reduce using rule 57 (exp -> NOT exp .)
    DIV             reduce using rule 57 (exp -> NOT exp .)
    MOD             reduce using rule 57 (exp -> NOT exp .)
    POW             reduce using rule 57 (exp -> NOT exp .)
    OR              reduce using rule 57 (exp -> NOT exp .)
    XOR             reduce using rule 57 (exp -> NOT exp .)
    AND             reduce using rule 57 (exp -> NOT exp .)
    TO              reduce using rule 57 (exp -> NOT exp .)
    IN              reduce using rule 57 (exp -> NOT exp .)
    CMP             reduce using rule 57 (exp -> NOT exp .)
    $end            reduce using rule 57 (exp -> NOT exp .)
    )               reduce using rule 57 (exp -> NOT exp .)
    ;               reduce using rule 57 (exp -> NOT exp .)
    }               reduce using rule 57 (exp -> NOT exp .)
    :               reduce using rule 57 (exp -> NOT exp .)
    ]               reduce using rule 57 (exp -> NOT exp .)
    END             reduce using rule 57 (exp -> NOT exp .)
    ELSE            reduce using rule 57 (exp -> NOT exp .)
    [               shift and go to state 23

  ! [               [ reduce using rule 57 (exp -> NOT exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! POW             [ shift and go to state 29 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 60

    (58) exp -> ECHO exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 58 (exp -> ECHO exp .)
    $end            reduce using rule 58 (exp -> ECHO exp .)
    )               reduce using rule 58 (exp -> ECHO exp .)
    ;               reduce using rule 58 (exp -> ECHO exp .)
    }               reduce using rule 58 (exp -> ECHO exp .)
    :               reduce using rule 58 (exp -> ECHO exp .)
    ]               reduce using rule 58 (exp -> ECHO exp .)
    END             reduce using rule 58 (exp -> ECHO exp .)
    ELSE            reduce using rule 58 (exp -> ECHO exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! [               [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! +               [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! -               [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! *               [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! DIV             [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! MOD             [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! POW             [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! OR              [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! XOR             [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! AND             [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! TO              [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! CMP             [ reduce using rule 58 (exp -> ECHO exp .) ]
  ! IN              [ shift and go to state 34 ]


state 61

    (59) exp -> LOAD exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 59 (exp -> LOAD exp .)
    $end            reduce using rule 59 (exp -> LOAD exp .)
    )               reduce using rule 59 (exp -> LOAD exp .)
    ;               reduce using rule 59 (exp -> LOAD exp .)
    }               reduce using rule 59 (exp -> LOAD exp .)
    :               reduce using rule 59 (exp -> LOAD exp .)
    ]               reduce using rule 59 (exp -> LOAD exp .)
    END             reduce using rule 59 (exp -> LOAD exp .)
    ELSE            reduce using rule 59 (exp -> LOAD exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! [               [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! +               [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! -               [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! *               [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! DIV             [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! MOD             [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! POW             [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! OR              [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! XOR             [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! AND             [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! TO              [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! CMP             [ reduce using rule 59 (exp -> LOAD exp .) ]
  ! IN              [ shift and go to state 34 ]


state 62

    (60) exp -> EVAL exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 60 (exp -> EVAL exp .)
    $end            reduce using rule 60 (exp -> EVAL exp .)
    )               reduce using rule 60 (exp -> EVAL exp .)
    ;               reduce using rule 60 (exp -> EVAL exp .)
    }               reduce using rule 60 (exp -> EVAL exp .)
    :               reduce using rule 60 (exp -> EVAL exp .)
    ]               reduce using rule 60 (exp -> EVAL exp .)
    END             reduce using rule 60 (exp -> EVAL exp .)
    ELSE            reduce using rule 60 (exp -> EVAL exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! [               [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! +               [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! -               [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! *               [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! DIV             [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! MOD             [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! POW             [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! OR              [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! XOR             [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! AND             [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! TO              [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! CMP             [ reduce using rule 60 (exp -> EVAL exp .) ]
  ! IN              [ shift and go to state 34 ]


state 63

    (64) exp -> { seq . }

    }               shift and go to state 108


state 64

    (61) seq -> exp . ; seq
    (62) seq -> exp . ;
    (63) seq -> exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ;               shift and go to state 109
    }               reduce using rule 63 (seq -> exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 65

    (67) exp -> WHILE exp . : exp END
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    :               shift and go to state 110
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 66

    (30) ifc -> IF exp . : exp
    (31) ifc -> IF exp . : exp ELSE exp
    (32) ifc -> IF exp . : exp ELSE ifc
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    :               shift and go to state 111
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 67

    (1) arr -> exp , exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 1 (arr -> exp , exp .)
    TO              reduce using rule 1 (arr -> exp , exp .)
    IN              reduce using rule 1 (arr -> exp , exp .)
    $end            reduce using rule 1 (arr -> exp , exp .)
    )               reduce using rule 1 (arr -> exp , exp .)
    ;               reduce using rule 1 (arr -> exp , exp .)
    }               reduce using rule 1 (arr -> exp , exp .)
    :               reduce using rule 1 (arr -> exp , exp .)
    ]               reduce using rule 1 (arr -> exp , exp .)
    END             reduce using rule 1 (arr -> exp , exp .)
    ELSE            reduce using rule 1 (arr -> exp , exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! +               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! -               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! *               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! DIV             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! MOD             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! POW             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! OR              [ reduce using rule 1 (arr -> exp , exp .) ]
  ! XOR             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! AND             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! CMP             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 68

    (6) exp -> exp [ exp . ]
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ]               shift and go to state 112
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 69

    (18) exp -> exp + exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 18 (exp -> exp + exp .)
    +               reduce using rule 18 (exp -> exp + exp .)
    -               reduce using rule 18 (exp -> exp + exp .)
    OR              reduce using rule 18 (exp -> exp + exp .)
    XOR             reduce using rule 18 (exp -> exp + exp .)
    AND             reduce using rule 18 (exp -> exp + exp .)
    TO              reduce using rule 18 (exp -> exp + exp .)
    IN              reduce using rule 18 (exp -> exp + exp .)
    CMP             reduce using rule 18 (exp -> exp + exp .)
    $end            reduce using rule 18 (exp -> exp + exp .)
    )               reduce using rule 18 (exp -> exp + exp .)
    ;               reduce using rule 18 (exp -> exp + exp .)
    }               reduce using rule 18 (exp -> exp + exp .)
    :               reduce using rule 18 (exp -> exp + exp .)
    ]               reduce using rule 18 (exp -> exp + exp .)
    END             reduce using rule 18 (exp -> exp + exp .)
    ELSE            reduce using rule 18 (exp -> exp + exp .)
    [               shift and go to state 23
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 18 (exp -> exp + exp .) ]
  ! *               [ reduce using rule 18 (exp -> exp + exp .) ]
  ! DIV             [ reduce using rule 18 (exp -> exp + exp .) ]
  ! MOD             [ reduce using rule 18 (exp -> exp + exp .) ]
  ! POW             [ reduce using rule 18 (exp -> exp + exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 70

    (19) exp -> exp - exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 19 (exp -> exp - exp .)
    +               reduce using rule 19 (exp -> exp - exp .)
    -               reduce using rule 19 (exp -> exp - exp .)
    OR              reduce using rule 19 (exp -> exp - exp .)
    XOR             reduce using rule 19 (exp -> exp - exp .)
    AND             reduce using rule 19 (exp -> exp - exp .)
    TO              reduce using rule 19 (exp -> exp - exp .)
    IN              reduce using rule 19 (exp -> exp - exp .)
    CMP             reduce using rule 19 (exp -> exp - exp .)
    $end            reduce using rule 19 (exp -> exp - exp .)
    )               reduce using rule 19 (exp -> exp - exp .)
    ;               reduce using rule 19 (exp -> exp - exp .)
    }               reduce using rule 19 (exp -> exp - exp .)
    :               reduce using rule 19 (exp -> exp - exp .)
    ]               reduce using rule 19 (exp -> exp - exp .)
    END             reduce using rule 19 (exp -> exp - exp .)
    ELSE            reduce using rule 19 (exp -> exp - exp .)
    [               shift and go to state 23
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 19 (exp -> exp - exp .) ]
  ! *               [ reduce using rule 19 (exp -> exp - exp .) ]
  ! DIV             [ reduce using rule 19 (exp -> exp - exp .) ]
  ! MOD             [ reduce using rule 19 (exp -> exp - exp .) ]
  ! POW             [ reduce using rule 19 (exp -> exp - exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 71

    (20) exp -> exp * exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 20 (exp -> exp * exp .)
    +               reduce using rule 20 (exp -> exp * exp .)
    -               reduce using rule 20 (exp -> exp * exp .)
    *               reduce using rule 20 (exp -> exp * exp .)
    DIV             reduce using rule 20 (exp -> exp * exp .)
    MOD             reduce using rule 20 (exp -> exp * exp .)
    OR              reduce using rule 20 (exp -> exp * exp .)
    XOR             reduce using rule 20 (exp -> exp * exp .)
    AND             reduce using rule 20 (exp -> exp * exp .)
    TO              reduce using rule 20 (exp -> exp * exp .)
    IN              reduce using rule 20 (exp -> exp * exp .)
    CMP             reduce using rule 20 (exp -> exp * exp .)
    $end            reduce using rule 20 (exp -> exp * exp .)
    )               reduce using rule 20 (exp -> exp * exp .)
    ;               reduce using rule 20 (exp -> exp * exp .)
    }               reduce using rule 20 (exp -> exp * exp .)
    :               reduce using rule 20 (exp -> exp * exp .)
    ]               reduce using rule 20 (exp -> exp * exp .)
    END             reduce using rule 20 (exp -> exp * exp .)
    ELSE            reduce using rule 20 (exp -> exp * exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 20 (exp -> exp * exp .) ]
  ! POW             [ reduce using rule 20 (exp -> exp * exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 72

    (21) exp -> exp DIV exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 21 (exp -> exp DIV exp .)
    +               reduce using rule 21 (exp -> exp DIV exp .)
    -               reduce using rule 21 (exp -> exp DIV exp .)
    *               reduce using rule 21 (exp -> exp DIV exp .)
    DIV             reduce using rule 21 (exp -> exp DIV exp .)
    MOD             reduce using rule 21 (exp -> exp DIV exp .)
    OR              reduce using rule 21 (exp -> exp DIV exp .)
    XOR             reduce using rule 21 (exp -> exp DIV exp .)
    AND             reduce using rule 21 (exp -> exp DIV exp .)
    TO              reduce using rule 21 (exp -> exp DIV exp .)
    IN              reduce using rule 21 (exp -> exp DIV exp .)
    CMP             reduce using rule 21 (exp -> exp DIV exp .)
    $end            reduce using rule 21 (exp -> exp DIV exp .)
    )               reduce using rule 21 (exp -> exp DIV exp .)
    ;               reduce using rule 21 (exp -> exp DIV exp .)
    }               reduce using rule 21 (exp -> exp DIV exp .)
    :               reduce using rule 21 (exp -> exp DIV exp .)
    ]               reduce using rule 21 (exp -> exp DIV exp .)
    END             reduce using rule 21 (exp -> exp DIV exp .)
    ELSE            reduce using rule 21 (exp -> exp DIV exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 21 (exp -> exp DIV exp .) ]
  ! POW             [ reduce using rule 21 (exp -> exp DIV exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 73

    (22) exp -> exp MOD exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 22 (exp -> exp MOD exp .)
    +               reduce using rule 22 (exp -> exp MOD exp .)
    -               reduce using rule 22 (exp -> exp MOD exp .)
    *               reduce using rule 22 (exp -> exp MOD exp .)
    DIV             reduce using rule 22 (exp -> exp MOD exp .)
    MOD             reduce using rule 22 (exp -> exp MOD exp .)
    OR              reduce using rule 22 (exp -> exp MOD exp .)
    XOR             reduce using rule 22 (exp -> exp MOD exp .)
    AND             reduce using rule 22 (exp -> exp MOD exp .)
    TO              reduce using rule 22 (exp -> exp MOD exp .)
    IN              reduce using rule 22 (exp -> exp MOD exp .)
    CMP             reduce using rule 22 (exp -> exp MOD exp .)
    $end            reduce using rule 22 (exp -> exp MOD exp .)
    )               reduce using rule 22 (exp -> exp MOD exp .)
    ;               reduce using rule 22 (exp -> exp MOD exp .)
    }               reduce using rule 22 (exp -> exp MOD exp .)
    :               reduce using rule 22 (exp -> exp MOD exp .)
    ]               reduce using rule 22 (exp -> exp MOD exp .)
    END             reduce using rule 22 (exp -> exp MOD exp .)
    ELSE            reduce using rule 22 (exp -> exp MOD exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 22 (exp -> exp MOD exp .) ]
  ! POW             [ reduce using rule 22 (exp -> exp MOD exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 74

    (23) exp -> exp POW exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 23 (exp -> exp POW exp .)
    +               reduce using rule 23 (exp -> exp POW exp .)
    -               reduce using rule 23 (exp -> exp POW exp .)
    *               reduce using rule 23 (exp -> exp POW exp .)
    DIV             reduce using rule 23 (exp -> exp POW exp .)
    MOD             reduce using rule 23 (exp -> exp POW exp .)
    OR              reduce using rule 23 (exp -> exp POW exp .)
    XOR             reduce using rule 23 (exp -> exp POW exp .)
    AND             reduce using rule 23 (exp -> exp POW exp .)
    TO              reduce using rule 23 (exp -> exp POW exp .)
    IN              reduce using rule 23 (exp -> exp POW exp .)
    CMP             reduce using rule 23 (exp -> exp POW exp .)
    $end            reduce using rule 23 (exp -> exp POW exp .)
    )               reduce using rule 23 (exp -> exp POW exp .)
    ;               reduce using rule 23 (exp -> exp POW exp .)
    }               reduce using rule 23 (exp -> exp POW exp .)
    :               reduce using rule 23 (exp -> exp POW exp .)
    ]               reduce using rule 23 (exp -> exp POW exp .)
    END             reduce using rule 23 (exp -> exp POW exp .)
    ELSE            reduce using rule 23 (exp -> exp POW exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 23 (exp -> exp POW exp .) ]
  ! POW             [ reduce using rule 23 (exp -> exp POW exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 75

    (24) exp -> exp OR exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 24 (exp -> exp OR exp .)
    OR              reduce using rule 24 (exp -> exp OR exp .)
    TO              reduce using rule 24 (exp -> exp OR exp .)
    IN              reduce using rule 24 (exp -> exp OR exp .)
    $end            reduce using rule 24 (exp -> exp OR exp .)
    )               reduce using rule 24 (exp -> exp OR exp .)
    ;               reduce using rule 24 (exp -> exp OR exp .)
    }               reduce using rule 24 (exp -> exp OR exp .)
    :               reduce using rule 24 (exp -> exp OR exp .)
    ]               reduce using rule 24 (exp -> exp OR exp .)
    END             reduce using rule 24 (exp -> exp OR exp .)
    ELSE            reduce using rule 24 (exp -> exp OR exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    XOR             shift and go to state 31
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! +               [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! -               [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! *               [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! DIV             [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! POW             [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! XOR             [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! CMP             [ reduce using rule 24 (exp -> exp OR exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 76

    (25) exp -> exp XOR exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 25 (exp -> exp XOR exp .)
    OR              reduce using rule 25 (exp -> exp XOR exp .)
    XOR             reduce using rule 25 (exp -> exp XOR exp .)
    TO              reduce using rule 25 (exp -> exp XOR exp .)
    IN              reduce using rule 25 (exp -> exp XOR exp .)
    $end            reduce using rule 25 (exp -> exp XOR exp .)
    )               reduce using rule 25 (exp -> exp XOR exp .)
    ;               reduce using rule 25 (exp -> exp XOR exp .)
    }               reduce using rule 25 (exp -> exp XOR exp .)
    :               reduce using rule 25 (exp -> exp XOR exp .)
    ]               reduce using rule 25 (exp -> exp XOR exp .)
    END             reduce using rule 25 (exp -> exp XOR exp .)
    ELSE            reduce using rule 25 (exp -> exp XOR exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! +               [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! -               [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! *               [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! DIV             [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! MOD             [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! POW             [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! AND             [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! CMP             [ reduce using rule 25 (exp -> exp XOR exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 77

    (26) exp -> exp AND exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 26 (exp -> exp AND exp .)
    OR              reduce using rule 26 (exp -> exp AND exp .)
    XOR             reduce using rule 26 (exp -> exp AND exp .)
    AND             reduce using rule 26 (exp -> exp AND exp .)
    TO              reduce using rule 26 (exp -> exp AND exp .)
    IN              reduce using rule 26 (exp -> exp AND exp .)
    $end            reduce using rule 26 (exp -> exp AND exp .)
    )               reduce using rule 26 (exp -> exp AND exp .)
    ;               reduce using rule 26 (exp -> exp AND exp .)
    }               reduce using rule 26 (exp -> exp AND exp .)
    :               reduce using rule 26 (exp -> exp AND exp .)
    ]               reduce using rule 26 (exp -> exp AND exp .)
    END             reduce using rule 26 (exp -> exp AND exp .)
    ELSE            reduce using rule 26 (exp -> exp AND exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    CMP             shift and go to state 35

  ! [               [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! +               [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! -               [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! *               [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! DIV             [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! POW             [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! CMP             [ reduce using rule 26 (exp -> exp AND exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 78

    (36) exp -> exp TO exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 36 (exp -> exp TO exp .)
    $end            reduce using rule 36 (exp -> exp TO exp .)
    )               reduce using rule 36 (exp -> exp TO exp .)
    ;               reduce using rule 36 (exp -> exp TO exp .)
    }               reduce using rule 36 (exp -> exp TO exp .)
    :               reduce using rule 36 (exp -> exp TO exp .)
    ]               reduce using rule 36 (exp -> exp TO exp .)
    END             reduce using rule 36 (exp -> exp TO exp .)
    ELSE            reduce using rule 36 (exp -> exp TO exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! [               [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! +               [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! -               [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! *               [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! DIV             [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! MOD             [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! POW             [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! OR              [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! XOR             [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! AND             [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! TO              [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! CMP             [ reduce using rule 36 (exp -> exp TO exp .) ]
  ! IN              [ shift and go to state 34 ]


state 79

    (45) exp -> exp IN it .

    ,               reduce using rule 45 (exp -> exp IN it .)
    [               reduce using rule 45 (exp -> exp IN it .)
    +               reduce using rule 45 (exp -> exp IN it .)
    -               reduce using rule 45 (exp -> exp IN it .)
    *               reduce using rule 45 (exp -> exp IN it .)
    DIV             reduce using rule 45 (exp -> exp IN it .)
    MOD             reduce using rule 45 (exp -> exp IN it .)
    POW             reduce using rule 45 (exp -> exp IN it .)
    OR              reduce using rule 45 (exp -> exp IN it .)
    XOR             reduce using rule 45 (exp -> exp IN it .)
    AND             reduce using rule 45 (exp -> exp IN it .)
    TO              reduce using rule 45 (exp -> exp IN it .)
    IN              reduce using rule 45 (exp -> exp IN it .)
    CMP             reduce using rule 45 (exp -> exp IN it .)
    $end            reduce using rule 45 (exp -> exp IN it .)
    )               reduce using rule 45 (exp -> exp IN it .)
    ;               reduce using rule 45 (exp -> exp IN it .)
    }               reduce using rule 45 (exp -> exp IN it .)
    :               reduce using rule 45 (exp -> exp IN it .)
    ]               reduce using rule 45 (exp -> exp IN it .)
    END             reduce using rule 45 (exp -> exp IN it .)
    ELSE            reduce using rule 45 (exp -> exp IN it .)


state 80

    (27) cmp -> exp CMP exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    CMP             reduce using rule 27 (cmp -> exp CMP exp .)
    ,               reduce using rule 27 (cmp -> exp CMP exp .)
    OR              reduce using rule 27 (cmp -> exp CMP exp .)
    XOR             reduce using rule 27 (cmp -> exp CMP exp .)
    AND             reduce using rule 27 (cmp -> exp CMP exp .)
    TO              reduce using rule 27 (cmp -> exp CMP exp .)
    IN              reduce using rule 27 (cmp -> exp CMP exp .)
    $end            reduce using rule 27 (cmp -> exp CMP exp .)
    )               reduce using rule 27 (cmp -> exp CMP exp .)
    ;               reduce using rule 27 (cmp -> exp CMP exp .)
    }               reduce using rule 27 (cmp -> exp CMP exp .)
    :               reduce using rule 27 (cmp -> exp CMP exp .)
    ]               reduce using rule 27 (cmp -> exp CMP exp .)
    END             reduce using rule 27 (cmp -> exp CMP exp .)
    ELSE            reduce using rule 27 (cmp -> exp CMP exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! +               [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! -               [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! *               [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! DIV             [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! MOD             [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! POW             [ reduce using rule 27 (cmp -> exp CMP exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 81

    (2) arr -> arr , exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 2 (arr -> arr , exp .)
    TO              reduce using rule 2 (arr -> arr , exp .)
    IN              reduce using rule 2 (arr -> arr , exp .)
    $end            reduce using rule 2 (arr -> arr , exp .)
    )               reduce using rule 2 (arr -> arr , exp .)
    ;               reduce using rule 2 (arr -> arr , exp .)
    }               reduce using rule 2 (arr -> arr , exp .)
    :               reduce using rule 2 (arr -> arr , exp .)
    ]               reduce using rule 2 (arr -> arr , exp .)
    END             reduce using rule 2 (arr -> arr , exp .)
    ELSE            reduce using rule 2 (arr -> arr , exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 2 (arr -> arr , exp .) ]
  ! +               [ reduce using rule 2 (arr -> arr , exp .) ]
  ! -               [ reduce using rule 2 (arr -> arr , exp .) ]
  ! *               [ reduce using rule 2 (arr -> arr , exp .) ]
  ! DIV             [ reduce using rule 2 (arr -> arr , exp .) ]
  ! MOD             [ reduce using rule 2 (arr -> arr , exp .) ]
  ! POW             [ reduce using rule 2 (arr -> arr , exp .) ]
  ! OR              [ reduce using rule 2 (arr -> arr , exp .) ]
  ! XOR             [ reduce using rule 2 (arr -> arr , exp .) ]
  ! AND             [ reduce using rule 2 (arr -> arr , exp .) ]
  ! CMP             [ reduce using rule 2 (arr -> arr , exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 82

    (38) exp -> ( exp ) .

    ,               reduce using rule 38 (exp -> ( exp ) .)
    [               reduce using rule 38 (exp -> ( exp ) .)
    +               reduce using rule 38 (exp -> ( exp ) .)
    -               reduce using rule 38 (exp -> ( exp ) .)
    *               reduce using rule 38 (exp -> ( exp ) .)
    DIV             reduce using rule 38 (exp -> ( exp ) .)
    MOD             reduce using rule 38 (exp -> ( exp ) .)
    POW             reduce using rule 38 (exp -> ( exp ) .)
    OR              reduce using rule 38 (exp -> ( exp ) .)
    XOR             reduce using rule 38 (exp -> ( exp ) .)
    AND             reduce using rule 38 (exp -> ( exp ) .)
    TO              reduce using rule 38 (exp -> ( exp ) .)
    IN              reduce using rule 38 (exp -> ( exp ) .)
    CMP             reduce using rule 38 (exp -> ( exp ) .)
    $end            reduce using rule 38 (exp -> ( exp ) .)
    )               reduce using rule 38 (exp -> ( exp ) .)
    ;               reduce using rule 38 (exp -> ( exp ) .)
    }               reduce using rule 38 (exp -> ( exp ) .)
    :               reduce using rule 38 (exp -> ( exp ) .)
    ]               reduce using rule 38 (exp -> ( exp ) .)
    END             reduce using rule 38 (exp -> ( exp ) .)
    ELSE            reduce using rule 38 (exp -> ( exp ) .)


state 83

    (40) it -> [ exp , . exp ]
    (42) it -> [ exp , . exp [
    (5) exp -> exp , .
    (1) arr -> exp , . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ,               reduce using rule 5 (exp -> exp , .)
    *               reduce using rule 5 (exp -> exp , .)
    DIV             reduce using rule 5 (exp -> exp , .)
    MOD             reduce using rule 5 (exp -> exp , .)
    POW             reduce using rule 5 (exp -> exp , .)
    OR              reduce using rule 5 (exp -> exp , .)
    XOR             reduce using rule 5 (exp -> exp , .)
    AND             reduce using rule 5 (exp -> exp , .)
    TO              reduce using rule 5 (exp -> exp , .)
    IN              reduce using rule 5 (exp -> exp , .)
    CMP             reduce using rule 5 (exp -> exp , .)
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

  ! [               [ reduce using rule 5 (exp -> exp , .) ]
  ! +               [ reduce using rule 5 (exp -> exp , .) ]
  ! -               [ reduce using rule 5 (exp -> exp , .) ]

    exp                            shift and go to state 113
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 84

    (41) it -> ] exp , . exp ]
    (43) it -> ] exp , . exp [
    (5) exp -> exp , .
    (1) arr -> exp , . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ,               reduce using rule 5 (exp -> exp , .)
    *               reduce using rule 5 (exp -> exp , .)
    DIV             reduce using rule 5 (exp -> exp , .)
    MOD             reduce using rule 5 (exp -> exp , .)
    POW             reduce using rule 5 (exp -> exp , .)
    OR              reduce using rule 5 (exp -> exp , .)
    XOR             reduce using rule 5 (exp -> exp , .)
    AND             reduce using rule 5 (exp -> exp , .)
    TO              reduce using rule 5 (exp -> exp , .)
    IN              reduce using rule 5 (exp -> exp , .)
    CMP             reduce using rule 5 (exp -> exp , .)
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

  ! [               [ reduce using rule 5 (exp -> exp , .) ]
  ! +               [ reduce using rule 5 (exp -> exp , .) ]
  ! -               [ reduce using rule 5 (exp -> exp , .) ]

    exp                            shift and go to state 114
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 85

    (7) exp -> ID + ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 115
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 86

    (46) exp -> ID + exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 46 (exp -> ID + exp .)
    +               reduce using rule 46 (exp -> ID + exp .)
    -               reduce using rule 46 (exp -> ID + exp .)
    OR              reduce using rule 46 (exp -> ID + exp .)
    XOR             reduce using rule 46 (exp -> ID + exp .)
    AND             reduce using rule 46 (exp -> ID + exp .)
    TO              reduce using rule 46 (exp -> ID + exp .)
    IN              reduce using rule 46 (exp -> ID + exp .)
    CMP             reduce using rule 46 (exp -> ID + exp .)
    $end            reduce using rule 46 (exp -> ID + exp .)
    )               reduce using rule 46 (exp -> ID + exp .)
    ;               reduce using rule 46 (exp -> ID + exp .)
    }               reduce using rule 46 (exp -> ID + exp .)
    :               reduce using rule 46 (exp -> ID + exp .)
    ]               reduce using rule 46 (exp -> ID + exp .)
    END             reduce using rule 46 (exp -> ID + exp .)
    ELSE            reduce using rule 46 (exp -> ID + exp .)
    [               shift and go to state 23
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 46 (exp -> ID + exp .) ]
  ! *               [ reduce using rule 46 (exp -> ID + exp .) ]
  ! DIV             [ reduce using rule 46 (exp -> ID + exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> ID + exp .) ]
  ! POW             [ reduce using rule 46 (exp -> ID + exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 87

    (17) exp -> ID ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 17 (exp -> ID ASG exp .)
    $end            reduce using rule 17 (exp -> ID ASG exp .)
    )               reduce using rule 17 (exp -> ID ASG exp .)
    ;               reduce using rule 17 (exp -> ID ASG exp .)
    }               reduce using rule 17 (exp -> ID ASG exp .)
    :               reduce using rule 17 (exp -> ID ASG exp .)
    ]               reduce using rule 17 (exp -> ID ASG exp .)
    END             reduce using rule 17 (exp -> ID ASG exp .)
    ELSE            reduce using rule 17 (exp -> ID ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! [               [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! +               [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! -               [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! *               [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! DIV             [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! MOD             [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! POW             [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! OR              [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! XOR             [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! AND             [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! TO              [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! CMP             [ reduce using rule 17 (exp -> ID ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 88

    (8) exp -> ID - ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 116
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 89

    (47) exp -> ID - exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 47 (exp -> ID - exp .)
    +               reduce using rule 47 (exp -> ID - exp .)
    -               reduce using rule 47 (exp -> ID - exp .)
    OR              reduce using rule 47 (exp -> ID - exp .)
    XOR             reduce using rule 47 (exp -> ID - exp .)
    AND             reduce using rule 47 (exp -> ID - exp .)
    TO              reduce using rule 47 (exp -> ID - exp .)
    IN              reduce using rule 47 (exp -> ID - exp .)
    CMP             reduce using rule 47 (exp -> ID - exp .)
    $end            reduce using rule 47 (exp -> ID - exp .)
    )               reduce using rule 47 (exp -> ID - exp .)
    ;               reduce using rule 47 (exp -> ID - exp .)
    }               reduce using rule 47 (exp -> ID - exp .)
    :               reduce using rule 47 (exp -> ID - exp .)
    ]               reduce using rule 47 (exp -> ID - exp .)
    END             reduce using rule 47 (exp -> ID - exp .)
    ELSE            reduce using rule 47 (exp -> ID - exp .)
    [               shift and go to state 23
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 47 (exp -> ID - exp .) ]
  ! *               [ reduce using rule 47 (exp -> ID - exp .) ]
  ! DIV             [ reduce using rule 47 (exp -> ID - exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> ID - exp .) ]
  ! POW             [ reduce using rule 47 (exp -> ID - exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 90

    (10) exp -> ID * ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 117
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 91

    (49) exp -> ID * exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 49 (exp -> ID * exp .)
    +               reduce using rule 49 (exp -> ID * exp .)
    -               reduce using rule 49 (exp -> ID * exp .)
    *               reduce using rule 49 (exp -> ID * exp .)
    DIV             reduce using rule 49 (exp -> ID * exp .)
    MOD             reduce using rule 49 (exp -> ID * exp .)
    OR              reduce using rule 49 (exp -> ID * exp .)
    XOR             reduce using rule 49 (exp -> ID * exp .)
    AND             reduce using rule 49 (exp -> ID * exp .)
    TO              reduce using rule 49 (exp -> ID * exp .)
    IN              reduce using rule 49 (exp -> ID * exp .)
    CMP             reduce using rule 49 (exp -> ID * exp .)
    $end            reduce using rule 49 (exp -> ID * exp .)
    )               reduce using rule 49 (exp -> ID * exp .)
    ;               reduce using rule 49 (exp -> ID * exp .)
    }               reduce using rule 49 (exp -> ID * exp .)
    :               reduce using rule 49 (exp -> ID * exp .)
    ]               reduce using rule 49 (exp -> ID * exp .)
    END             reduce using rule 49 (exp -> ID * exp .)
    ELSE            reduce using rule 49 (exp -> ID * exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 49 (exp -> ID * exp .) ]
  ! POW             [ reduce using rule 49 (exp -> ID * exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 92

    (11) exp -> ID DIV ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 118
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 93

    (50) exp -> ID DIV exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 50 (exp -> ID DIV exp .)
    +               reduce using rule 50 (exp -> ID DIV exp .)
    -               reduce using rule 50 (exp -> ID DIV exp .)
    *               reduce using rule 50 (exp -> ID DIV exp .)
    DIV             reduce using rule 50 (exp -> ID DIV exp .)
    MOD             reduce using rule 50 (exp -> ID DIV exp .)
    OR              reduce using rule 50 (exp -> ID DIV exp .)
    XOR             reduce using rule 50 (exp -> ID DIV exp .)
    AND             reduce using rule 50 (exp -> ID DIV exp .)
    TO              reduce using rule 50 (exp -> ID DIV exp .)
    IN              reduce using rule 50 (exp -> ID DIV exp .)
    CMP             reduce using rule 50 (exp -> ID DIV exp .)
    $end            reduce using rule 50 (exp -> ID DIV exp .)
    )               reduce using rule 50 (exp -> ID DIV exp .)
    ;               reduce using rule 50 (exp -> ID DIV exp .)
    }               reduce using rule 50 (exp -> ID DIV exp .)
    :               reduce using rule 50 (exp -> ID DIV exp .)
    ]               reduce using rule 50 (exp -> ID DIV exp .)
    END             reduce using rule 50 (exp -> ID DIV exp .)
    ELSE            reduce using rule 50 (exp -> ID DIV exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 50 (exp -> ID DIV exp .) ]
  ! POW             [ reduce using rule 50 (exp -> ID DIV exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 94

    (12) exp -> ID MOD ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 119
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 95

    (51) exp -> ID MOD exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 51 (exp -> ID MOD exp .)
    +               reduce using rule 51 (exp -> ID MOD exp .)
    -               reduce using rule 51 (exp -> ID MOD exp .)
    *               reduce using rule 51 (exp -> ID MOD exp .)
    DIV             reduce using rule 51 (exp -> ID MOD exp .)
    MOD             reduce using rule 51 (exp -> ID MOD exp .)
    OR              reduce using rule 51 (exp -> ID MOD exp .)
    XOR             reduce using rule 51 (exp -> ID MOD exp .)
    AND             reduce using rule 51 (exp -> ID MOD exp .)
    TO              reduce using rule 51 (exp -> ID MOD exp .)
    IN              reduce using rule 51 (exp -> ID MOD exp .)
    CMP             reduce using rule 51 (exp -> ID MOD exp .)
    $end            reduce using rule 51 (exp -> ID MOD exp .)
    )               reduce using rule 51 (exp -> ID MOD exp .)
    ;               reduce using rule 51 (exp -> ID MOD exp .)
    }               reduce using rule 51 (exp -> ID MOD exp .)
    :               reduce using rule 51 (exp -> ID MOD exp .)
    ]               reduce using rule 51 (exp -> ID MOD exp .)
    END             reduce using rule 51 (exp -> ID MOD exp .)
    ELSE            reduce using rule 51 (exp -> ID MOD exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 51 (exp -> ID MOD exp .) ]
  ! POW             [ reduce using rule 51 (exp -> ID MOD exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 96

    (13) exp -> ID POW ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 120
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 97

    (52) exp -> ID POW exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 52 (exp -> ID POW exp .)
    +               reduce using rule 52 (exp -> ID POW exp .)
    -               reduce using rule 52 (exp -> ID POW exp .)
    *               reduce using rule 52 (exp -> ID POW exp .)
    DIV             reduce using rule 52 (exp -> ID POW exp .)
    MOD             reduce using rule 52 (exp -> ID POW exp .)
    OR              reduce using rule 52 (exp -> ID POW exp .)
    XOR             reduce using rule 52 (exp -> ID POW exp .)
    AND             reduce using rule 52 (exp -> ID POW exp .)
    TO              reduce using rule 52 (exp -> ID POW exp .)
    IN              reduce using rule 52 (exp -> ID POW exp .)
    CMP             reduce using rule 52 (exp -> ID POW exp .)
    $end            reduce using rule 52 (exp -> ID POW exp .)
    )               reduce using rule 52 (exp -> ID POW exp .)
    ;               reduce using rule 52 (exp -> ID POW exp .)
    }               reduce using rule 52 (exp -> ID POW exp .)
    :               reduce using rule 52 (exp -> ID POW exp .)
    ]               reduce using rule 52 (exp -> ID POW exp .)
    END             reduce using rule 52 (exp -> ID POW exp .)
    ELSE            reduce using rule 52 (exp -> ID POW exp .)
    [               shift and go to state 23
    POW             shift and go to state 29

  ! [               [ reduce using rule 52 (exp -> ID POW exp .) ]
  ! POW             [ reduce using rule 52 (exp -> ID POW exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! +               [ shift and go to state 24 ]
  ! -               [ shift and go to state 25 ]
  ! *               [ shift and go to state 26 ]
  ! DIV             [ shift and go to state 27 ]
  ! MOD             [ shift and go to state 28 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 98

    (14) exp -> ID OR ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 121
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 99

    (53) exp -> ID OR exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 53 (exp -> ID OR exp .)
    OR              reduce using rule 53 (exp -> ID OR exp .)
    TO              reduce using rule 53 (exp -> ID OR exp .)
    IN              reduce using rule 53 (exp -> ID OR exp .)
    $end            reduce using rule 53 (exp -> ID OR exp .)
    )               reduce using rule 53 (exp -> ID OR exp .)
    ;               reduce using rule 53 (exp -> ID OR exp .)
    }               reduce using rule 53 (exp -> ID OR exp .)
    :               reduce using rule 53 (exp -> ID OR exp .)
    ]               reduce using rule 53 (exp -> ID OR exp .)
    END             reduce using rule 53 (exp -> ID OR exp .)
    ELSE            reduce using rule 53 (exp -> ID OR exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    XOR             shift and go to state 31
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! +               [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! -               [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! *               [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! DIV             [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! POW             [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! XOR             [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! AND             [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! CMP             [ reduce using rule 53 (exp -> ID OR exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 100

    (15) exp -> ID XOR ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 122
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 101

    (54) exp -> ID XOR exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 54 (exp -> ID XOR exp .)
    OR              reduce using rule 54 (exp -> ID XOR exp .)
    XOR             reduce using rule 54 (exp -> ID XOR exp .)
    TO              reduce using rule 54 (exp -> ID XOR exp .)
    IN              reduce using rule 54 (exp -> ID XOR exp .)
    $end            reduce using rule 54 (exp -> ID XOR exp .)
    )               reduce using rule 54 (exp -> ID XOR exp .)
    ;               reduce using rule 54 (exp -> ID XOR exp .)
    }               reduce using rule 54 (exp -> ID XOR exp .)
    :               reduce using rule 54 (exp -> ID XOR exp .)
    ]               reduce using rule 54 (exp -> ID XOR exp .)
    END             reduce using rule 54 (exp -> ID XOR exp .)
    ELSE            reduce using rule 54 (exp -> ID XOR exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! +               [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! -               [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! *               [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! DIV             [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! MOD             [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! POW             [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! AND             [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! CMP             [ reduce using rule 54 (exp -> ID XOR exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 102

    (16) exp -> ID AND ASG . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 123
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 103

    (55) exp -> ID AND exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ,               reduce using rule 55 (exp -> ID AND exp .)
    OR              reduce using rule 55 (exp -> ID AND exp .)
    XOR             reduce using rule 55 (exp -> ID AND exp .)
    AND             reduce using rule 55 (exp -> ID AND exp .)
    TO              reduce using rule 55 (exp -> ID AND exp .)
    IN              reduce using rule 55 (exp -> ID AND exp .)
    $end            reduce using rule 55 (exp -> ID AND exp .)
    )               reduce using rule 55 (exp -> ID AND exp .)
    ;               reduce using rule 55 (exp -> ID AND exp .)
    }               reduce using rule 55 (exp -> ID AND exp .)
    :               reduce using rule 55 (exp -> ID AND exp .)
    ]               reduce using rule 55 (exp -> ID AND exp .)
    END             reduce using rule 55 (exp -> ID AND exp .)
    ELSE            reduce using rule 55 (exp -> ID AND exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    CMP             shift and go to state 35

  ! [               [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! +               [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! -               [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! *               [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! DIV             [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! POW             [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! CMP             [ reduce using rule 55 (exp -> ID AND exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 104

    (37) exp -> ID ( exp . )
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    )               shift and go to state 124
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 105

    (28) cmp -> cmp CMP exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    CMP             reduce using rule 28 (cmp -> cmp CMP exp .)
    ,               reduce using rule 28 (cmp -> cmp CMP exp .)
    OR              reduce using rule 28 (cmp -> cmp CMP exp .)
    XOR             reduce using rule 28 (cmp -> cmp CMP exp .)
    AND             reduce using rule 28 (cmp -> cmp CMP exp .)
    TO              reduce using rule 28 (cmp -> cmp CMP exp .)
    IN              reduce using rule 28 (cmp -> cmp CMP exp .)
    $end            reduce using rule 28 (cmp -> cmp CMP exp .)
    )               reduce using rule 28 (cmp -> cmp CMP exp .)
    ;               reduce using rule 28 (cmp -> cmp CMP exp .)
    }               reduce using rule 28 (cmp -> cmp CMP exp .)
    :               reduce using rule 28 (cmp -> cmp CMP exp .)
    ]               reduce using rule 28 (cmp -> cmp CMP exp .)
    END             reduce using rule 28 (cmp -> cmp CMP exp .)
    ELSE            reduce using rule 28 (cmp -> cmp CMP exp .)
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29

  ! [               [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! +               [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! -               [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! *               [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! DIV             [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! MOD             [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! POW             [ reduce using rule 28 (cmp -> cmp CMP exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! OR              [ shift and go to state 30 ]
  ! XOR             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 32 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]
  ! CMP             [ shift and go to state 35 ]


state 106

    (34) exp -> FOR ID IN . exp : exp END
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 125
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 107

    (35) exp -> FOR NUM ID . IN it : exp END

    IN              shift and go to state 126


state 108

    (64) exp -> { seq } .

    ,               reduce using rule 64 (exp -> { seq } .)
    [               reduce using rule 64 (exp -> { seq } .)
    +               reduce using rule 64 (exp -> { seq } .)
    -               reduce using rule 64 (exp -> { seq } .)
    *               reduce using rule 64 (exp -> { seq } .)
    DIV             reduce using rule 64 (exp -> { seq } .)
    MOD             reduce using rule 64 (exp -> { seq } .)
    POW             reduce using rule 64 (exp -> { seq } .)
    OR              reduce using rule 64 (exp -> { seq } .)
    XOR             reduce using rule 64 (exp -> { seq } .)
    AND             reduce using rule 64 (exp -> { seq } .)
    TO              reduce using rule 64 (exp -> { seq } .)
    IN              reduce using rule 64 (exp -> { seq } .)
    CMP             reduce using rule 64 (exp -> { seq } .)
    $end            reduce using rule 64 (exp -> { seq } .)
    )               reduce using rule 64 (exp -> { seq } .)
    ;               reduce using rule 64 (exp -> { seq } .)
    }               reduce using rule 64 (exp -> { seq } .)
    :               reduce using rule 64 (exp -> { seq } .)
    ]               reduce using rule 64 (exp -> { seq } .)
    END             reduce using rule 64 (exp -> { seq } .)
    ELSE            reduce using rule 64 (exp -> { seq } .)


state 109

    (61) seq -> exp ; . seq
    (62) seq -> exp ; .
    (61) seq -> . exp ; seq
    (62) seq -> . exp ;
    (63) seq -> . exp
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    }               reduce using rule 62 (seq -> exp ; .)
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 64
    seq                            shift and go to state 127
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 110

    (67) exp -> WHILE exp : . exp END
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 128
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 111

    (30) ifc -> IF exp : . exp
    (31) ifc -> IF exp : . exp ELSE exp
    (32) ifc -> IF exp : . exp ELSE ifc
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 129
    ifc                            shift and go to state 10
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    it                             shift and go to state 13

state 112

    (6) exp -> exp [ exp ] .

    ,               reduce using rule 6 (exp -> exp [ exp ] .)
    [               reduce using rule 6 (exp -> exp [ exp ] .)
    +               reduce using rule 6 (exp -> exp [ exp ] .)
    -               reduce using rule 6 (exp -> exp [ exp ] .)
    *               reduce using rule 6 (exp -> exp [ exp ] .)
    DIV             reduce using rule 6 (exp -> exp [ exp ] .)
    MOD             reduce using rule 6 (exp -> exp [ exp ] .)
    POW             reduce using rule 6 (exp -> exp [ exp ] .)
    OR              reduce using rule 6 (exp -> exp [ exp ] .)
    XOR             reduce using rule 6 (exp -> exp [ exp ] .)
    AND             reduce using rule 6 (exp -> exp [ exp ] .)
    TO              reduce using rule 6 (exp -> exp [ exp ] .)
    IN              reduce using rule 6 (exp -> exp [ exp ] .)
    CMP             reduce using rule 6 (exp -> exp [ exp ] .)
    $end            reduce using rule 6 (exp -> exp [ exp ] .)
    )               reduce using rule 6 (exp -> exp [ exp ] .)
    ;               reduce using rule 6 (exp -> exp [ exp ] .)
    }               reduce using rule 6 (exp -> exp [ exp ] .)
    :               reduce using rule 6 (exp -> exp [ exp ] .)
    ]               reduce using rule 6 (exp -> exp [ exp ] .)
    END             reduce using rule 6 (exp -> exp [ exp ] .)
    ELSE            reduce using rule 6 (exp -> exp [ exp ] .)


state 113

    (40) it -> [ exp , exp . ]
    (42) it -> [ exp , exp . [
    (1) arr -> exp , exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ]               shift and go to state 131
    [               shift and go to state 130
    ,               reduce using rule 1 (arr -> exp , exp .)
    TO              reduce using rule 1 (arr -> exp , exp .)
    IN              reduce using rule 1 (arr -> exp , exp .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! +               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! -               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! *               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! DIV             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! MOD             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! POW             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! OR              [ reduce using rule 1 (arr -> exp , exp .) ]
  ! XOR             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! AND             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! CMP             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 114

    (41) it -> ] exp , exp . ]
    (43) it -> ] exp , exp . [
    (1) arr -> exp , exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    ]               shift and go to state 132
    [               shift and go to state 133
    ,               reduce using rule 1 (arr -> exp , exp .)
    TO              reduce using rule 1 (arr -> exp , exp .)
    IN              reduce using rule 1 (arr -> exp , exp .)
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    CMP             shift and go to state 35

  ! [               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! +               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! -               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! *               [ reduce using rule 1 (arr -> exp , exp .) ]
  ! DIV             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! MOD             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! POW             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! OR              [ reduce using rule 1 (arr -> exp , exp .) ]
  ! XOR             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! AND             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! CMP             [ reduce using rule 1 (arr -> exp , exp .) ]
  ! ,               [ shift and go to state 22 ]
  ! TO              [ shift and go to state 33 ]
  ! IN              [ shift and go to state 34 ]


state 115

    (7) exp -> ID + ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 7 (exp -> ID + ASG exp .)
    $end            reduce using rule 7 (exp -> ID + ASG exp .)
    )               reduce using rule 7 (exp -> ID + ASG exp .)
    ;               reduce using rule 7 (exp -> ID + ASG exp .)
    }               reduce using rule 7 (exp -> ID + ASG exp .)
    :               reduce using rule 7 (exp -> ID + ASG exp .)
    ]               reduce using rule 7 (exp -> ID + ASG exp .)
    END             reduce using rule 7 (exp -> ID + ASG exp .)
    ELSE            reduce using rule 7 (exp -> ID + ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! [               [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! +               [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! -               [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! *               [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! DIV             [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! MOD             [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! POW             [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! OR              [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! XOR             [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! AND             [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! TO              [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! CMP             [ reduce using rule 7 (exp -> ID + ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 116

    (8) exp -> ID - ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 8 (exp -> ID - ASG exp .)
    $end            reduce using rule 8 (exp -> ID - ASG exp .)
    )               reduce using rule 8 (exp -> ID - ASG exp .)
    ;               reduce using rule 8 (exp -> ID - ASG exp .)
    }               reduce using rule 8 (exp -> ID - ASG exp .)
    :               reduce using rule 8 (exp -> ID - ASG exp .)
    ]               reduce using rule 8 (exp -> ID - ASG exp .)
    END             reduce using rule 8 (exp -> ID - ASG exp .)
    ELSE            reduce using rule 8 (exp -> ID - ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! [               [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! +               [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! -               [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! *               [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! DIV             [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! MOD             [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! POW             [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! OR              [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! XOR             [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! AND             [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! TO              [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! CMP             [ reduce using rule 8 (exp -> ID - ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 117

    (10) exp -> ID * ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 10 (exp -> ID * ASG exp .)
    $end            reduce using rule 10 (exp -> ID * ASG exp .)
    )               reduce using rule 10 (exp -> ID * ASG exp .)
    ;               reduce using rule 10 (exp -> ID * ASG exp .)
    }               reduce using rule 10 (exp -> ID * ASG exp .)
    :               reduce using rule 10 (exp -> ID * ASG exp .)
    ]               reduce using rule 10 (exp -> ID * ASG exp .)
    END             reduce using rule 10 (exp -> ID * ASG exp .)
    ELSE            reduce using rule 10 (exp -> ID * ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! [               [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! +               [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! -               [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! *               [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! DIV             [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! MOD             [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! POW             [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! OR              [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! XOR             [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! AND             [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! TO              [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! CMP             [ reduce using rule 10 (exp -> ID * ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 118

    (11) exp -> ID DIV ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 11 (exp -> ID DIV ASG exp .)
    $end            reduce using rule 11 (exp -> ID DIV ASG exp .)
    )               reduce using rule 11 (exp -> ID DIV ASG exp .)
    ;               reduce using rule 11 (exp -> ID DIV ASG exp .)
    }               reduce using rule 11 (exp -> ID DIV ASG exp .)
    :               reduce using rule 11 (exp -> ID DIV ASG exp .)
    ]               reduce using rule 11 (exp -> ID DIV ASG exp .)
    END             reduce using rule 11 (exp -> ID DIV ASG exp .)
    ELSE            reduce using rule 11 (exp -> ID DIV ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! [               [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! +               [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! -               [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! *               [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! DIV             [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! MOD             [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! POW             [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! OR              [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! XOR             [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! AND             [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! TO              [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! CMP             [ reduce using rule 11 (exp -> ID DIV ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 119

    (12) exp -> ID MOD ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 12 (exp -> ID MOD ASG exp .)
    $end            reduce using rule 12 (exp -> ID MOD ASG exp .)
    )               reduce using rule 12 (exp -> ID MOD ASG exp .)
    ;               reduce using rule 12 (exp -> ID MOD ASG exp .)
    }               reduce using rule 12 (exp -> ID MOD ASG exp .)
    :               reduce using rule 12 (exp -> ID MOD ASG exp .)
    ]               reduce using rule 12 (exp -> ID MOD ASG exp .)
    END             reduce using rule 12 (exp -> ID MOD ASG exp .)
    ELSE            reduce using rule 12 (exp -> ID MOD ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! [               [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! +               [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! -               [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! *               [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! DIV             [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! MOD             [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! POW             [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! OR              [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! XOR             [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! AND             [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! TO              [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! CMP             [ reduce using rule 12 (exp -> ID MOD ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 120

    (13) exp -> ID POW ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 13 (exp -> ID POW ASG exp .)
    $end            reduce using rule 13 (exp -> ID POW ASG exp .)
    )               reduce using rule 13 (exp -> ID POW ASG exp .)
    ;               reduce using rule 13 (exp -> ID POW ASG exp .)
    }               reduce using rule 13 (exp -> ID POW ASG exp .)
    :               reduce using rule 13 (exp -> ID POW ASG exp .)
    ]               reduce using rule 13 (exp -> ID POW ASG exp .)
    END             reduce using rule 13 (exp -> ID POW ASG exp .)
    ELSE            reduce using rule 13 (exp -> ID POW ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! [               [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! +               [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! -               [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! *               [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! DIV             [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! MOD             [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! POW             [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! OR              [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! XOR             [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! AND             [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! TO              [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! CMP             [ reduce using rule 13 (exp -> ID POW ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 121

    (14) exp -> ID OR ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 14 (exp -> ID OR ASG exp .)
    $end            reduce using rule 14 (exp -> ID OR ASG exp .)
    )               reduce using rule 14 (exp -> ID OR ASG exp .)
    ;               reduce using rule 14 (exp -> ID OR ASG exp .)
    }               reduce using rule 14 (exp -> ID OR ASG exp .)
    :               reduce using rule 14 (exp -> ID OR ASG exp .)
    ]               reduce using rule 14 (exp -> ID OR ASG exp .)
    END             reduce using rule 14 (exp -> ID OR ASG exp .)
    ELSE            reduce using rule 14 (exp -> ID OR ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! [               [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! +               [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! -               [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! *               [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! DIV             [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! MOD             [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! POW             [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! OR              [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! XOR             [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! AND             [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! TO              [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! CMP             [ reduce using rule 14 (exp -> ID OR ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 122

    (15) exp -> ID XOR ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 15 (exp -> ID XOR ASG exp .)
    $end            reduce using rule 15 (exp -> ID XOR ASG exp .)
    )               reduce using rule 15 (exp -> ID XOR ASG exp .)
    ;               reduce using rule 15 (exp -> ID XOR ASG exp .)
    }               reduce using rule 15 (exp -> ID XOR ASG exp .)
    :               reduce using rule 15 (exp -> ID XOR ASG exp .)
    ]               reduce using rule 15 (exp -> ID XOR ASG exp .)
    END             reduce using rule 15 (exp -> ID XOR ASG exp .)
    ELSE            reduce using rule 15 (exp -> ID XOR ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! [               [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! +               [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! -               [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! *               [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! DIV             [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! MOD             [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! POW             [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! OR              [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! XOR             [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! AND             [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! TO              [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! CMP             [ reduce using rule 15 (exp -> ID XOR ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 123

    (16) exp -> ID AND ASG exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    IN              reduce using rule 16 (exp -> ID AND ASG exp .)
    $end            reduce using rule 16 (exp -> ID AND ASG exp .)
    )               reduce using rule 16 (exp -> ID AND ASG exp .)
    ;               reduce using rule 16 (exp -> ID AND ASG exp .)
    }               reduce using rule 16 (exp -> ID AND ASG exp .)
    :               reduce using rule 16 (exp -> ID AND ASG exp .)
    ]               reduce using rule 16 (exp -> ID AND ASG exp .)
    END             reduce using rule 16 (exp -> ID AND ASG exp .)
    ELSE            reduce using rule 16 (exp -> ID AND ASG exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    CMP             shift and go to state 35

  ! ,               [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! [               [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! +               [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! -               [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! *               [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! DIV             [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! MOD             [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! POW             [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! OR              [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! XOR             [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! AND             [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! TO              [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! CMP             [ reduce using rule 16 (exp -> ID AND ASG exp .) ]
  ! IN              [ shift and go to state 34 ]


state 124

    (37) exp -> ID ( exp ) .

    ,               reduce using rule 37 (exp -> ID ( exp ) .)
    [               reduce using rule 37 (exp -> ID ( exp ) .)
    +               reduce using rule 37 (exp -> ID ( exp ) .)
    -               reduce using rule 37 (exp -> ID ( exp ) .)
    *               reduce using rule 37 (exp -> ID ( exp ) .)
    DIV             reduce using rule 37 (exp -> ID ( exp ) .)
    MOD             reduce using rule 37 (exp -> ID ( exp ) .)
    POW             reduce using rule 37 (exp -> ID ( exp ) .)
    OR              reduce using rule 37 (exp -> ID ( exp ) .)
    XOR             reduce using rule 37 (exp -> ID ( exp ) .)
    AND             reduce using rule 37 (exp -> ID ( exp ) .)
    TO              reduce using rule 37 (exp -> ID ( exp ) .)
    IN              reduce using rule 37 (exp -> ID ( exp ) .)
    CMP             reduce using rule 37 (exp -> ID ( exp ) .)
    $end            reduce using rule 37 (exp -> ID ( exp ) .)
    )               reduce using rule 37 (exp -> ID ( exp ) .)
    ;               reduce using rule 37 (exp -> ID ( exp ) .)
    }               reduce using rule 37 (exp -> ID ( exp ) .)
    :               reduce using rule 37 (exp -> ID ( exp ) .)
    ]               reduce using rule 37 (exp -> ID ( exp ) .)
    END             reduce using rule 37 (exp -> ID ( exp ) .)
    ELSE            reduce using rule 37 (exp -> ID ( exp ) .)


state 125

    (34) exp -> FOR ID IN exp . : exp END
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    :               shift and go to state 134
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 126

    (35) exp -> FOR NUM ID IN . it : exp END
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    [               shift and go to state 4
    ]               shift and go to state 5

    it                             shift and go to state 135

state 127

    (61) seq -> exp ; seq .

    }               reduce using rule 61 (seq -> exp ; seq .)


state 128

    (67) exp -> WHILE exp : exp . END
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    END             shift and go to state 136
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 129

    (30) ifc -> IF exp : exp .
    (31) ifc -> IF exp : exp . ELSE exp
    (32) ifc -> IF exp : exp . ELSE ifc
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    END             reduce using rule 30 (ifc -> IF exp : exp .)
    ELSE            shift and go to state 137
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 130

    (42) it -> [ exp , exp [ .
    (6) exp -> exp [ . exp ]
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ,               reduce using rule 42 (it -> [ exp , exp [ .)
    [               reduce using rule 42 (it -> [ exp , exp [ .)
    +               reduce using rule 42 (it -> [ exp , exp [ .)
    -               reduce using rule 42 (it -> [ exp , exp [ .)
    *               reduce using rule 42 (it -> [ exp , exp [ .)
    DIV             reduce using rule 42 (it -> [ exp , exp [ .)
    MOD             reduce using rule 42 (it -> [ exp , exp [ .)
    POW             reduce using rule 42 (it -> [ exp , exp [ .)
    OR              reduce using rule 42 (it -> [ exp , exp [ .)
    XOR             reduce using rule 42 (it -> [ exp , exp [ .)
    AND             reduce using rule 42 (it -> [ exp , exp [ .)
    TO              reduce using rule 42 (it -> [ exp , exp [ .)
    IN              reduce using rule 42 (it -> [ exp , exp [ .)
    CMP             reduce using rule 42 (it -> [ exp , exp [ .)
    $end            reduce using rule 42 (it -> [ exp , exp [ .)
    )               reduce using rule 42 (it -> [ exp , exp [ .)
    ;               reduce using rule 42 (it -> [ exp , exp [ .)
    }               reduce using rule 42 (it -> [ exp , exp [ .)
    :               reduce using rule 42 (it -> [ exp , exp [ .)
    ]               reduce using rule 42 (it -> [ exp , exp [ .)
    END             reduce using rule 42 (it -> [ exp , exp [ .)
    ELSE            reduce using rule 42 (it -> [ exp , exp [ .)
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21

  ! -               [ shift and go to state 8 ]
  ! +               [ shift and go to state 7 ]
  ! [               [ shift and go to state 4 ]
  ! ]               [ shift and go to state 5 ]

    exp                            shift and go to state 68
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 131

    (40) it -> [ exp , exp ] .

    ,               reduce using rule 40 (it -> [ exp , exp ] .)
    [               reduce using rule 40 (it -> [ exp , exp ] .)
    +               reduce using rule 40 (it -> [ exp , exp ] .)
    -               reduce using rule 40 (it -> [ exp , exp ] .)
    *               reduce using rule 40 (it -> [ exp , exp ] .)
    DIV             reduce using rule 40 (it -> [ exp , exp ] .)
    MOD             reduce using rule 40 (it -> [ exp , exp ] .)
    POW             reduce using rule 40 (it -> [ exp , exp ] .)
    OR              reduce using rule 40 (it -> [ exp , exp ] .)
    XOR             reduce using rule 40 (it -> [ exp , exp ] .)
    AND             reduce using rule 40 (it -> [ exp , exp ] .)
    TO              reduce using rule 40 (it -> [ exp , exp ] .)
    IN              reduce using rule 40 (it -> [ exp , exp ] .)
    CMP             reduce using rule 40 (it -> [ exp , exp ] .)
    $end            reduce using rule 40 (it -> [ exp , exp ] .)
    )               reduce using rule 40 (it -> [ exp , exp ] .)
    ;               reduce using rule 40 (it -> [ exp , exp ] .)
    }               reduce using rule 40 (it -> [ exp , exp ] .)
    :               reduce using rule 40 (it -> [ exp , exp ] .)
    ]               reduce using rule 40 (it -> [ exp , exp ] .)
    END             reduce using rule 40 (it -> [ exp , exp ] .)
    ELSE            reduce using rule 40 (it -> [ exp , exp ] .)


state 132

    (41) it -> ] exp , exp ] .

    ,               reduce using rule 41 (it -> ] exp , exp ] .)
    [               reduce using rule 41 (it -> ] exp , exp ] .)
    +               reduce using rule 41 (it -> ] exp , exp ] .)
    -               reduce using rule 41 (it -> ] exp , exp ] .)
    *               reduce using rule 41 (it -> ] exp , exp ] .)
    DIV             reduce using rule 41 (it -> ] exp , exp ] .)
    MOD             reduce using rule 41 (it -> ] exp , exp ] .)
    POW             reduce using rule 41 (it -> ] exp , exp ] .)
    OR              reduce using rule 41 (it -> ] exp , exp ] .)
    XOR             reduce using rule 41 (it -> ] exp , exp ] .)
    AND             reduce using rule 41 (it -> ] exp , exp ] .)
    TO              reduce using rule 41 (it -> ] exp , exp ] .)
    IN              reduce using rule 41 (it -> ] exp , exp ] .)
    CMP             reduce using rule 41 (it -> ] exp , exp ] .)
    $end            reduce using rule 41 (it -> ] exp , exp ] .)
    )               reduce using rule 41 (it -> ] exp , exp ] .)
    ;               reduce using rule 41 (it -> ] exp , exp ] .)
    }               reduce using rule 41 (it -> ] exp , exp ] .)
    :               reduce using rule 41 (it -> ] exp , exp ] .)
    ]               reduce using rule 41 (it -> ] exp , exp ] .)
    END             reduce using rule 41 (it -> ] exp , exp ] .)
    ELSE            reduce using rule 41 (it -> ] exp , exp ] .)


state 133

    (43) it -> ] exp , exp [ .
    (6) exp -> exp [ . exp ]
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    ,               reduce using rule 43 (it -> ] exp , exp [ .)
    [               reduce using rule 43 (it -> ] exp , exp [ .)
    +               reduce using rule 43 (it -> ] exp , exp [ .)
    -               reduce using rule 43 (it -> ] exp , exp [ .)
    *               reduce using rule 43 (it -> ] exp , exp [ .)
    DIV             reduce using rule 43 (it -> ] exp , exp [ .)
    MOD             reduce using rule 43 (it -> ] exp , exp [ .)
    POW             reduce using rule 43 (it -> ] exp , exp [ .)
    OR              reduce using rule 43 (it -> ] exp , exp [ .)
    XOR             reduce using rule 43 (it -> ] exp , exp [ .)
    AND             reduce using rule 43 (it -> ] exp , exp [ .)
    TO              reduce using rule 43 (it -> ] exp , exp [ .)
    IN              reduce using rule 43 (it -> ] exp , exp [ .)
    CMP             reduce using rule 43 (it -> ] exp , exp [ .)
    $end            reduce using rule 43 (it -> ] exp , exp [ .)
    )               reduce using rule 43 (it -> ] exp , exp [ .)
    ;               reduce using rule 43 (it -> ] exp , exp [ .)
    }               reduce using rule 43 (it -> ] exp , exp [ .)
    :               reduce using rule 43 (it -> ] exp , exp [ .)
    ]               reduce using rule 43 (it -> ] exp , exp [ .)
    END             reduce using rule 43 (it -> ] exp , exp [ .)
    ELSE            reduce using rule 43 (it -> ] exp , exp [ .)
    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21

  ! -               [ shift and go to state 8 ]
  ! +               [ shift and go to state 7 ]
  ! [               [ shift and go to state 4 ]
  ! ]               [ shift and go to state 5 ]

    exp                            shift and go to state 68
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 134

    (34) exp -> FOR ID IN exp : . exp END
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 138
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10
    it                             shift and go to state 13

state 135

    (35) exp -> FOR NUM ID IN it . : exp END

    :               shift and go to state 139


state 136

    (67) exp -> WHILE exp : exp END .

    ,               reduce using rule 67 (exp -> WHILE exp : exp END .)
    [               reduce using rule 67 (exp -> WHILE exp : exp END .)
    +               reduce using rule 67 (exp -> WHILE exp : exp END .)
    -               reduce using rule 67 (exp -> WHILE exp : exp END .)
    *               reduce using rule 67 (exp -> WHILE exp : exp END .)
    DIV             reduce using rule 67 (exp -> WHILE exp : exp END .)
    MOD             reduce using rule 67 (exp -> WHILE exp : exp END .)
    POW             reduce using rule 67 (exp -> WHILE exp : exp END .)
    OR              reduce using rule 67 (exp -> WHILE exp : exp END .)
    XOR             reduce using rule 67 (exp -> WHILE exp : exp END .)
    AND             reduce using rule 67 (exp -> WHILE exp : exp END .)
    TO              reduce using rule 67 (exp -> WHILE exp : exp END .)
    IN              reduce using rule 67 (exp -> WHILE exp : exp END .)
    CMP             reduce using rule 67 (exp -> WHILE exp : exp END .)
    $end            reduce using rule 67 (exp -> WHILE exp : exp END .)
    )               reduce using rule 67 (exp -> WHILE exp : exp END .)
    ;               reduce using rule 67 (exp -> WHILE exp : exp END .)
    }               reduce using rule 67 (exp -> WHILE exp : exp END .)
    :               reduce using rule 67 (exp -> WHILE exp : exp END .)
    ]               reduce using rule 67 (exp -> WHILE exp : exp END .)
    END             reduce using rule 67 (exp -> WHILE exp : exp END .)
    ELSE            reduce using rule 67 (exp -> WHILE exp : exp END .)


state 137

    (31) ifc -> IF exp : exp ELSE . exp
    (32) ifc -> IF exp : exp ELSE . ifc
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    exp                            shift and go to state 140
    ifc                            shift and go to state 141
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    it                             shift and go to state 13

state 138

    (34) exp -> FOR ID IN exp : exp . END
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    END             shift and go to state 142
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 139

    (35) exp -> FOR NUM ID IN it : . exp END
    (3) exp -> . arr
    (4) exp -> . ( )
    (5) exp -> . exp ,
    (6) exp -> . exp [ exp ]
    (7) exp -> . ID + ASG exp
    (8) exp -> . ID - ASG exp
    (9) exp -> . ID USG
    (10) exp -> . ID * ASG exp
    (11) exp -> . ID DIV ASG exp
    (12) exp -> . ID MOD ASG exp
    (13) exp -> . ID POW ASG exp
    (14) exp -> . ID OR ASG exp
    (15) exp -> . ID XOR ASG exp
    (16) exp -> . ID AND ASG exp
    (17) exp -> . ID ASG exp
    (18) exp -> . exp + exp
    (19) exp -> . exp - exp
    (20) exp -> . exp * exp
    (21) exp -> . exp DIV exp
    (22) exp -> . exp MOD exp
    (23) exp -> . exp POW exp
    (24) exp -> . exp OR exp
    (25) exp -> . exp XOR exp
    (26) exp -> . exp AND exp
    (29) exp -> . cmp
    (33) exp -> . ifc END
    (34) exp -> . FOR ID IN exp : exp END
    (35) exp -> . FOR NUM ID IN it : exp END
    (36) exp -> . exp TO exp
    (37) exp -> . ID ( exp )
    (38) exp -> . ( exp )
    (39) exp -> . ID
    (44) exp -> . it
    (45) exp -> . exp IN it
    (46) exp -> . ID + exp
    (47) exp -> . ID - exp
    (48) exp -> . - exp
    (49) exp -> . ID * exp
    (50) exp -> . ID DIV exp
    (51) exp -> . ID MOD exp
    (52) exp -> . ID POW exp
    (53) exp -> . ID OR exp
    (54) exp -> . ID XOR exp
    (55) exp -> . ID AND exp
    (56) exp -> . + exp
    (57) exp -> . NOT exp
    (58) exp -> . ECHO exp
    (59) exp -> . LOAD exp
    (60) exp -> . EVAL exp
    (64) exp -> . { seq }
    (65) exp -> . NUM
    (66) exp -> . STR
    (67) exp -> . WHILE exp : exp END
    (1) arr -> . exp , exp
    (2) arr -> . arr , exp
    (27) cmp -> . exp CMP exp
    (28) cmp -> . cmp CMP exp
    (30) ifc -> . IF exp : exp
    (31) ifc -> . IF exp : exp ELSE exp
    (32) ifc -> . IF exp : exp ELSE ifc
    (40) it -> . [ exp , exp ]
    (41) it -> . ] exp , exp ]
    (42) it -> . [ exp , exp [
    (43) it -> . ] exp , exp [

    (               shift and go to state 3
    ID              shift and go to state 6
    FOR             shift and go to state 11
    -               shift and go to state 8
    +               shift and go to state 7
    NOT             shift and go to state 14
    ECHO            shift and go to state 15
    LOAD            shift and go to state 16
    EVAL            shift and go to state 17
    {               shift and go to state 18
    NUM             shift and go to state 12
    STR             shift and go to state 19
    WHILE           shift and go to state 20
    IF              shift and go to state 21
    [               shift and go to state 4
    ]               shift and go to state 5

    it                             shift and go to state 13
    exp                            shift and go to state 143
    arr                            shift and go to state 2
    cmp                            shift and go to state 9
    ifc                            shift and go to state 10

state 140

    (31) ifc -> IF exp : exp ELSE exp .
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    END             reduce using rule 31 (ifc -> IF exp : exp ELSE exp .)
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 141

    (32) ifc -> IF exp : exp ELSE ifc .
    (33) exp -> ifc . END

    END             reduce using rule 32 (ifc -> IF exp : exp ELSE ifc .)

  ! END             [ shift and go to state 56 ]


state 142

    (34) exp -> FOR ID IN exp : exp END .

    ,               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    [               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    +               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    -               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    *               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    DIV             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    MOD             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    POW             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    OR              reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    XOR             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    AND             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    TO              reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    IN              reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    CMP             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    $end            reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    )               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    ;               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    }               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    :               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    ]               reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    END             reduce using rule 34 (exp -> FOR ID IN exp : exp END .)
    ELSE            reduce using rule 34 (exp -> FOR ID IN exp : exp END .)


state 143

    (35) exp -> FOR NUM ID IN it : exp . END
    (5) exp -> exp . ,
    (6) exp -> exp . [ exp ]
    (18) exp -> exp . + exp
    (19) exp -> exp . - exp
    (20) exp -> exp . * exp
    (21) exp -> exp . DIV exp
    (22) exp -> exp . MOD exp
    (23) exp -> exp . POW exp
    (24) exp -> exp . OR exp
    (25) exp -> exp . XOR exp
    (26) exp -> exp . AND exp
    (36) exp -> exp . TO exp
    (45) exp -> exp . IN it
    (1) arr -> exp . , exp
    (27) cmp -> exp . CMP exp

    END             shift and go to state 144
    ,               shift and go to state 22
    [               shift and go to state 23
    +               shift and go to state 24
    -               shift and go to state 25
    *               shift and go to state 26
    DIV             shift and go to state 27
    MOD             shift and go to state 28
    POW             shift and go to state 29
    OR              shift and go to state 30
    XOR             shift and go to state 31
    AND             shift and go to state 32
    TO              shift and go to state 33
    IN              shift and go to state 34
    CMP             shift and go to state 35


state 144

    (35) exp -> FOR NUM ID IN it : exp END .

    ,               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    [               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    +               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    -               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    *               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    DIV             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    MOD             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    POW             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    OR              reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    XOR             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    AND             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    TO              reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    IN              reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    CMP             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    $end            reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    )               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    ;               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    }               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    :               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    ]               reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    END             reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)
    ELSE            reduce using rule 35 (exp -> FOR NUM ID IN it : exp END .)

